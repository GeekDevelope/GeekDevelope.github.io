<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Gyatso Ichiro</title>
  
  <subtitle>嘉措壹郎</subtitle>
  <link href="http://example.com/atom.xml" rel="self"/>
  
  <link href="http://example.com/"/>
  <updated>2021-12-18T04:30:35.249Z</updated>
  <id>http://example.com/</id>
  
  <author>
    <name>嘉措壹郎</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>2.1.1 Linux 网络编程</title>
    <link href="http://example.com/2021/12/15/2.1.1.Linux%20%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/"/>
    <id>http://example.com/2021/12/15/2.1.1.Linux%20%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/</id>
    <published>2021-12-15T07:34:04.000Z</published>
    <updated>2021-12-18T04:30:35.249Z</updated>
    
    <content type="html"><![CDATA[<h1 id="2-1-1-Linux-网络编程"><a href="#2-1-1-Linux-网络编程" class="headerlink" title="2.1.1 Linux 网络编程"></a>2.1.1 Linux 网络编程</h1><hr><blockquote><p><strong>重点内容</strong></p><ul><li><strong>计算机网络的定义</strong></li><li><strong>计算机网络的性能指标</strong></li><li><strong>计算机网络体系结构</strong></li><li><strong>Linux TCP/IP 网络编程基础</strong></li><li><strong>协议簇</strong></li><li><strong>socket() 系统调用</strong></li><li><strong>TCP Server 和 TCP Client 编程</strong></li><li><strong>UDP Server 和 UDP Client 编程</strong></li></ul></blockquote><hr><h2 id="2-1-1-1-计算机网络的定义"><a href="#2-1-1-1-计算机网络的定义" class="headerlink" title="2.1.1.1 计算机网络的定义"></a>2.1.1.1 计算机网络的定义</h2><ul><li><p><strong>一些相互连接的、自治的计算机的集合</strong></p><ul><li><p><strong>广域网 WAN(Wide Area Network)：广域网是英特网的核心部分，其任务是通过长距离运送主机所发送的数据，有时也称为远程网(Long haul network)</strong></p></li><li><p><strong>城域网 MAN(Metropolitan Area Network)：城域网的作用范围一般是一个城市，目前很多城域网采用的是以太网技术</strong></p></li><li><p><strong>局域网 LAN(Local Area Network)：局域网一般用微型计算机或工作站通过高速通信线路相连，例如：校园网、企业网等</strong></p></li><li><p><strong>公用网(public network)：公用网指电信公司出资建造的大型网络，公用网也称为公众网</strong></p></li><li><p><strong>专用网(private network)：这是某个部门为本单位的特殊业务工作的需要而建造的网络，不向本单位以外的人服务</strong></p></li></ul></li></ul><hr><h2 id="2-1-1-2-计算机网络的性能指标"><a href="#2-1-1-2-计算机网络的性能指标" class="headerlink" title="2.1.1.2 计算机网络的性能指标"></a>2.1.1.2 计算机网络的性能指标</h2><ul><li><p><strong>速率：网络技术中的速率指的是连接在计算机网络上的主机在数字信道上传送数据的速率，也称为数据率(data rate)或比特率(bit rate)，单位：比特每秒(bit/s，bps)</strong></p></li><li><p><strong>带宽(bandwidth)：带宽用来表示网络的通信线路所能传送数据的能力，网络带宽指在单位时间内从网络中的某一点到另一点所能通过的最高数据率</strong></p></li><li><p><strong>吞吐量(throughput)：吞吐量表示在单位时间内通过某个网络信道或接口的数据量，吞吐量受网络带宽或网络额定速率的限制，有时吞吐量可以用每秒传送的字节数或帧数来表示</strong></p></li><li><p><strong>时延(delay 或 latency)：是指数据(一个报文或分组，甚至比特)从网络(或链路)的一端传送到另一端所需的时间，网络时延由以下几个部分组成：</strong></p></li></ul><blockquote><ul><li><strong>发送时延(transmission delay)：发送时延是主机或路由器发送数据帧所需要的时间，也就是从发送数据帧的第一个比特算起，到该帧最后一个比特发送完毕所需的时间，发送时延也叫传输时延，发送时延的计算公式：</strong></li></ul></blockquote><p><mjx-container class="MathJax" jax="SVG" display="true"><svg style="vertical-align: -2.172ex" xmlns="http://www.w3.org/2000/svg" width="25.225ex" height="5.475ex" role="img" focusable="false" viewBox="0 -1460 11149.6 2420"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="scale(1,-1)"><g data-mml-node="math"><g data-mml-node="mi"><text data-variant="italic" transform="scale(1,-1)" font-size="884px" font-family="serif" font-style="italic">发</text></g><g data-mml-node="mi" transform="translate(900,0)"><text data-variant="italic" transform="scale(1,-1)" font-size="884px" font-family="serif" font-style="italic">送</text></g><g data-mml-node="mi" transform="translate(1800,0)"><text data-variant="italic" transform="scale(1,-1)" font-size="884px" font-family="serif" font-style="italic">时</text></g><g data-mml-node="mi" transform="translate(2700,0)"><text data-variant="italic" transform="scale(1,-1)" font-size="884px" font-family="serif" font-style="italic">延</text></g><g data-mml-node="mo" transform="translate(3877.8,0)"><path data-c="3D" d="M56 347Q56 360 70 367H707Q722 359 722 347Q722 336 708 328L390 327H72Q56 332 56 347ZM56 153Q56 168 72 173H708Q722 163 722 153Q722 140 707 133H70Q56 140 56 153Z"></path></g><g data-mml-node="mfrac" transform="translate(4933.6,0)"><g data-mml-node="mrow" transform="translate(254.5,710)"><g data-mml-node="mi"><text data-variant="italic" transform="scale(1,-1)" font-size="884px" font-family="serif" font-style="italic">数</text></g><g data-mml-node="mi" transform="translate(900,0)"><text data-variant="italic" transform="scale(1,-1)" font-size="884px" font-family="serif" font-style="italic">据</text></g><g data-mml-node="mi" transform="translate(1800,0)"><text data-variant="italic" transform="scale(1,-1)" font-size="884px" font-family="serif" font-style="italic">帧</text></g><g data-mml-node="mi" transform="translate(2700,0)"><text data-variant="italic" transform="scale(1,-1)" font-size="884px" font-family="serif" font-style="italic">长</text></g><g data-mml-node="mi" transform="translate(3600,0)"><text data-variant="italic" transform="scale(1,-1)" font-size="884px" font-family="serif" font-style="italic">度</text></g><g data-mml-node="mo" transform="translate(4500,0)"><path data-c="28" d="M94 250Q94 319 104 381T127 488T164 576T202 643T244 695T277 729T302 750H315H319Q333 750 333 741Q333 738 316 720T275 667T226 581T184 443T167 250T184 58T225 -81T274 -167T316 -220T333 -241Q333 -250 318 -250H315H302L274 -226Q180 -141 137 -14T94 250Z"></path></g><g data-mml-node="mi" transform="translate(4889,0)"><path data-c="1D44F" d="M73 647Q73 657 77 670T89 683Q90 683 161 688T234 694Q246 694 246 685T212 542Q204 508 195 472T180 418L176 399Q176 396 182 402Q231 442 283 442Q345 442 383 396T422 280Q422 169 343 79T173 -11Q123 -11 82 27T40 150V159Q40 180 48 217T97 414Q147 611 147 623T109 637Q104 637 101 637H96Q86 637 83 637T76 640T73 647ZM336 325V331Q336 405 275 405Q258 405 240 397T207 376T181 352T163 330L157 322L136 236Q114 150 114 114Q114 66 138 42Q154 26 178 26Q211 26 245 58Q270 81 285 114T318 219Q336 291 336 325Z"></path></g><g data-mml-node="mo" transform="translate(5318,0)"><path data-c="29" d="M60 749L64 750Q69 750 74 750H86L114 726Q208 641 251 514T294 250Q294 182 284 119T261 12T224 -76T186 -143T145 -194T113 -227T90 -246Q87 -249 86 -250H74Q66 -250 63 -250T58 -247T55 -238Q56 -237 66 -225Q221 -64 221 250T66 725Q56 737 55 738Q55 746 60 749Z"></path></g></g><g data-mml-node="mrow" transform="translate(220,-710)"><g data-mml-node="mi"><text data-variant="italic" transform="scale(1,-1)" font-size="884px" font-family="serif" font-style="italic">信</text></g><g data-mml-node="mi" transform="translate(900,0)"><text data-variant="italic" transform="scale(1,-1)" font-size="884px" font-family="serif" font-style="italic">道</text></g><g data-mml-node="mi" transform="translate(1800,0)"><text data-variant="italic" transform="scale(1,-1)" font-size="884px" font-family="serif" font-style="italic">带</text></g><g data-mml-node="mi" transform="translate(2700,0)"><text data-variant="italic" transform="scale(1,-1)" font-size="884px" font-family="serif" font-style="italic">宽</text></g><g data-mml-node="mo" transform="translate(3600,0)"><path data-c="28" d="M94 250Q94 319 104 381T127 488T164 576T202 643T244 695T277 729T302 750H315H319Q333 750 333 741Q333 738 316 720T275 667T226 581T184 443T167 250T184 58T225 -81T274 -167T316 -220T333 -241Q333 -250 318 -250H315H302L274 -226Q180 -141 137 -14T94 250Z"></path></g><g data-mml-node="mi" transform="translate(3989,0)"><path data-c="1D44F" d="M73 647Q73 657 77 670T89 683Q90 683 161 688T234 694Q246 694 246 685T212 542Q204 508 195 472T180 418L176 399Q176 396 182 402Q231 442 283 442Q345 442 383 396T422 280Q422 169 343 79T173 -11Q123 -11 82 27T40 150V159Q40 180 48 217T97 414Q147 611 147 623T109 637Q104 637 101 637H96Q86 637 83 637T76 640T73 647ZM336 325V331Q336 405 275 405Q258 405 240 397T207 376T181 352T163 330L157 322L136 236Q114 150 114 114Q114 66 138 42Q154 26 178 26Q211 26 245 58Q270 81 285 114T318 219Q336 291 336 325Z"></path></g><g data-mml-node="TeXAtom" data-mjx-texclass="ORD" transform="translate(4418,0)"><g data-mml-node="mo"><path data-c="2F" d="M423 750Q432 750 438 744T444 730Q444 725 271 248T92 -240Q85 -250 75 -250Q68 -250 62 -245T56 -231Q56 -221 230 257T407 740Q411 750 423 750Z"></path></g></g><g data-mml-node="mi" transform="translate(4918,0)"><path data-c="1D460" d="M131 289Q131 321 147 354T203 415T300 442Q362 442 390 415T419 355Q419 323 402 308T364 292Q351 292 340 300T328 326Q328 342 337 354T354 372T367 378Q368 378 368 379Q368 382 361 388T336 399T297 405Q249 405 227 379T204 326Q204 301 223 291T278 274T330 259Q396 230 396 163Q396 135 385 107T352 51T289 7T195 -10Q118 -10 86 19T53 87Q53 126 74 143T118 160Q133 160 146 151T160 120Q160 94 142 76T111 58Q109 57 108 57T107 55Q108 52 115 47T146 34T201 27Q237 27 263 38T301 66T318 97T323 122Q323 150 302 164T254 181T195 196T148 231Q131 256 131 289Z"></path></g><g data-mml-node="mo" transform="translate(5387,0)"><path data-c="29" d="M60 749L64 750Q69 750 74 750H86L114 726Q208 641 251 514T294 250Q294 182 284 119T261 12T224 -76T186 -143T145 -194T113 -227T90 -246Q87 -249 86 -250H74Q66 -250 63 -250T58 -247T55 -238Q56 -237 66 -225Q221 -64 221 250T66 725Q56 737 55 738Q55 746 60 749Z"></path></g></g><rect width="5976" height="60" x="120" y="220"></rect></g></g></g></svg></mjx-container></p><blockquote><ul><li><strong>传播时延(propagation dlay)：传播时延是电磁波在信道中传播一定的距离需要花费的时间，计算公式：</strong></li></ul></blockquote><p><mjx-container class="MathJax" jax="SVG" display="true"><svg style="vertical-align: -2.172ex" xmlns="http://www.w3.org/2000/svg" width="42.531ex" height="5.475ex" role="img" focusable="false" viewBox="0 -1460 18798.6 2420"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="scale(1,-1)"><g data-mml-node="math"><g data-mml-node="mi"><text data-variant="italic" transform="scale(1,-1)" font-size="884px" font-family="serif" font-style="italic">传</text></g><g data-mml-node="mi" transform="translate(900,0)"><text data-variant="italic" transform="scale(1,-1)" font-size="884px" font-family="serif" font-style="italic">播</text></g><g data-mml-node="mi" transform="translate(1800,0)"><text data-variant="italic" transform="scale(1,-1)" font-size="884px" font-family="serif" font-style="italic">时</text></g><g data-mml-node="mi" transform="translate(2700,0)"><text data-variant="italic" transform="scale(1,-1)" font-size="884px" font-family="serif" font-style="italic">延</text></g><g data-mml-node="mo" transform="translate(3877.8,0)"><path data-c="3D" d="M56 347Q56 360 70 367H707Q722 359 722 347Q722 336 708 328L390 327H72Q56 332 56 347ZM56 153Q56 168 72 173H708Q722 163 722 153Q722 140 707 133H70Q56 140 56 153Z"></path></g><g data-mml-node="mfrac" transform="translate(4933.6,0)"><g data-mml-node="mrow" transform="translate(4304.5,710)"><g data-mml-node="mi"><text data-variant="italic" transform="scale(1,-1)" font-size="884px" font-family="serif" font-style="italic">信</text></g><g data-mml-node="mi" transform="translate(900,0)"><text data-variant="italic" transform="scale(1,-1)" font-size="884px" font-family="serif" font-style="italic">道</text></g><g data-mml-node="mi" transform="translate(1800,0)"><text data-variant="italic" transform="scale(1,-1)" font-size="884px" font-family="serif" font-style="italic">长</text></g><g data-mml-node="mi" transform="translate(2700,0)"><text data-variant="italic" transform="scale(1,-1)" font-size="884px" font-family="serif" font-style="italic">度</text></g><g data-mml-node="mo" transform="translate(3600,0)"><path data-c="28" d="M94 250Q94 319 104 381T127 488T164 576T202 643T244 695T277 729T302 750H315H319Q333 750 333 741Q333 738 316 720T275 667T226 581T184 443T167 250T184 58T225 -81T274 -167T316 -220T333 -241Q333 -250 318 -250H315H302L274 -226Q180 -141 137 -14T94 250Z"></path></g><g data-mml-node="mi" transform="translate(3989,0)"><path data-c="1D45A" d="M21 287Q22 293 24 303T36 341T56 388T88 425T132 442T175 435T205 417T221 395T229 376L231 369Q231 367 232 367L243 378Q303 442 384 442Q401 442 415 440T441 433T460 423T475 411T485 398T493 385T497 373T500 364T502 357L510 367Q573 442 659 442Q713 442 746 415T780 336Q780 285 742 178T704 50Q705 36 709 31T724 26Q752 26 776 56T815 138Q818 149 821 151T837 153Q857 153 857 145Q857 144 853 130Q845 101 831 73T785 17T716 -10Q669 -10 648 17T627 73Q627 92 663 193T700 345Q700 404 656 404H651Q565 404 506 303L499 291L466 157Q433 26 428 16Q415 -11 385 -11Q372 -11 364 -4T353 8T350 18Q350 29 384 161L420 307Q423 322 423 345Q423 404 379 404H374Q288 404 229 303L222 291L189 157Q156 26 151 16Q138 -11 108 -11Q95 -11 87 -5T76 7T74 17Q74 30 112 181Q151 335 151 342Q154 357 154 369Q154 405 129 405Q107 405 92 377T69 316T57 280Q55 278 41 278H27Q21 284 21 287Z"></path></g><g data-mml-node="mo" transform="translate(4867,0)"><path data-c="29" d="M60 749L64 750Q69 750 74 750H86L114 726Q208 641 251 514T294 250Q294 182 284 119T261 12T224 -76T186 -143T145 -194T113 -227T90 -246Q87 -249 86 -250H74Q66 -250 63 -250T58 -247T55 -238Q56 -237 66 -225Q221 -64 221 250T66 725Q56 737 55 738Q55 746 60 749Z"></path></g></g><g data-mml-node="mrow" transform="translate(220,-710)"><g data-mml-node="mi"><text data-variant="italic" transform="scale(1,-1)" font-size="884px" font-family="serif" font-style="italic">电</text></g><g data-mml-node="mi" transform="translate(900,0)"><text data-variant="italic" transform="scale(1,-1)" font-size="884px" font-family="serif" font-style="italic">磁</text></g><g data-mml-node="mi" transform="translate(1800,0)"><text data-variant="italic" transform="scale(1,-1)" font-size="884px" font-family="serif" font-style="italic">波</text></g><g data-mml-node="mi" transform="translate(2700,0)"><text data-variant="italic" transform="scale(1,-1)" font-size="884px" font-family="serif" font-style="italic">在</text></g><g data-mml-node="mi" transform="translate(3600,0)"><text data-variant="italic" transform="scale(1,-1)" font-size="884px" font-family="serif" font-style="italic">信</text></g><g data-mml-node="mi" transform="translate(4500,0)"><text data-variant="italic" transform="scale(1,-1)" font-size="884px" font-family="serif" font-style="italic">道</text></g><g data-mml-node="mi" transform="translate(5400,0)"><text data-variant="italic" transform="scale(1,-1)" font-size="884px" font-family="serif" font-style="italic">上</text></g><g data-mml-node="mi" transform="translate(6300,0)"><text data-variant="italic" transform="scale(1,-1)" font-size="884px" font-family="serif" font-style="italic">传</text></g><g data-mml-node="mi" transform="translate(7200,0)"><text data-variant="italic" transform="scale(1,-1)" font-size="884px" font-family="serif" font-style="italic">播</text></g><g data-mml-node="mi" transform="translate(8100,0)"><text data-variant="italic" transform="scale(1,-1)" font-size="884px" font-family="serif" font-style="italic">的</text></g><g data-mml-node="mi" transform="translate(9000,0)"><text data-variant="italic" transform="scale(1,-1)" font-size="884px" font-family="serif" font-style="italic">速</text></g><g data-mml-node="mi" transform="translate(9900,0)"><text data-variant="italic" transform="scale(1,-1)" font-size="884px" font-family="serif" font-style="italic">率</text></g><g data-mml-node="mo" transform="translate(10800,0)"><path data-c="28" d="M94 250Q94 319 104 381T127 488T164 576T202 643T244 695T277 729T302 750H315H319Q333 750 333 741Q333 738 316 720T275 667T226 581T184 443T167 250T184 58T225 -81T274 -167T316 -220T333 -241Q333 -250 318 -250H315H302L274 -226Q180 -141 137 -14T94 250Z"></path></g><g data-mml-node="mi" transform="translate(11189,0)"><path data-c="1D45A" d="M21 287Q22 293 24 303T36 341T56 388T88 425T132 442T175 435T205 417T221 395T229 376L231 369Q231 367 232 367L243 378Q303 442 384 442Q401 442 415 440T441 433T460 423T475 411T485 398T493 385T497 373T500 364T502 357L510 367Q573 442 659 442Q713 442 746 415T780 336Q780 285 742 178T704 50Q705 36 709 31T724 26Q752 26 776 56T815 138Q818 149 821 151T837 153Q857 153 857 145Q857 144 853 130Q845 101 831 73T785 17T716 -10Q669 -10 648 17T627 73Q627 92 663 193T700 345Q700 404 656 404H651Q565 404 506 303L499 291L466 157Q433 26 428 16Q415 -11 385 -11Q372 -11 364 -4T353 8T350 18Q350 29 384 161L420 307Q423 322 423 345Q423 404 379 404H374Q288 404 229 303L222 291L189 157Q156 26 151 16Q138 -11 108 -11Q95 -11 87 -5T76 7T74 17Q74 30 112 181Q151 335 151 342Q154 357 154 369Q154 405 129 405Q107 405 92 377T69 316T57 280Q55 278 41 278H27Q21 284 21 287Z"></path></g><g data-mml-node="TeXAtom" data-mjx-texclass="ORD" transform="translate(12067,0)"><g data-mml-node="mo"><path data-c="2F" d="M423 750Q432 750 438 744T444 730Q444 725 271 248T92 -240Q85 -250 75 -250Q68 -250 62 -245T56 -231Q56 -221 230 257T407 740Q411 750 423 750Z"></path></g></g><g data-mml-node="mi" transform="translate(12567,0)"><path data-c="1D460" d="M131 289Q131 321 147 354T203 415T300 442Q362 442 390 415T419 355Q419 323 402 308T364 292Q351 292 340 300T328 326Q328 342 337 354T354 372T367 378Q368 378 368 379Q368 382 361 388T336 399T297 405Q249 405 227 379T204 326Q204 301 223 291T278 274T330 259Q396 230 396 163Q396 135 385 107T352 51T289 7T195 -10Q118 -10 86 19T53 87Q53 126 74 143T118 160Q133 160 146 151T160 120Q160 94 142 76T111 58Q109 57 108 57T107 55Q108 52 115 47T146 34T201 27Q237 27 263 38T301 66T318 97T323 122Q323 150 302 164T254 181T195 196T148 231Q131 256 131 289Z"></path></g><g data-mml-node="mo" transform="translate(13036,0)"><path data-c="29" d="M60 749L64 750Q69 750 74 750H86L114 726Q208 641 251 514T294 250Q294 182 284 119T261 12T224 -76T186 -143T145 -194T113 -227T90 -246Q87 -249 86 -250H74Q66 -250 63 -250T58 -247T55 -238Q56 -237 66 -225Q221 -64 221 250T66 725Q56 737 55 738Q55 746 60 749Z"></path></g></g><rect width="13625" height="60" x="120" y="220"></rect></g></g></g></svg></mjx-container></p><blockquote><ul><li><strong>处理时延：主机或路由在收到分组时要花费一定的时间进行处理</strong></li></ul></blockquote><blockquote><ul><li><strong>排队时延：分组在进入路由器后需要在输入队列排队等待处理，在路由器确定了转发接口后还需要在输出队列中排队等待转发，就产生了排队时延，排队时延的长短往往取决于网络当时的通信量</strong></li></ul></blockquote><blockquote><p> <em><strong>总时延等于发送时延、传播时延、处理时延和排队时延的总和</strong></em></p></blockquote><p><mjx-container class="MathJax" jax="SVG" display="true"><svg style="vertical-align: -0.452ex" xmlns="http://www.w3.org/2000/svg" width="50.002ex" height="2.149ex" role="img" focusable="false" viewBox="0 -750 22100.9 950"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="scale(1,-1)"><g data-mml-node="math"><g data-mml-node="mi"><text data-variant="italic" transform="scale(1,-1)" font-size="884px" font-family="serif" font-style="italic">总</text></g><g data-mml-node="mi" transform="translate(900,0)"><text data-variant="italic" transform="scale(1,-1)" font-size="884px" font-family="serif" font-style="italic">时</text></g><g data-mml-node="mi" transform="translate(1800,0)"><text data-variant="italic" transform="scale(1,-1)" font-size="884px" font-family="serif" font-style="italic">延</text></g><g data-mml-node="mo" transform="translate(2977.8,0)"><path data-c="3D" d="M56 347Q56 360 70 367H707Q722 359 722 347Q722 336 708 328L390 327H72Q56 332 56 347ZM56 153Q56 168 72 173H708Q722 163 722 153Q722 140 707 133H70Q56 140 56 153Z"></path></g><g data-mml-node="mi" transform="translate(4033.6,0)"><text data-variant="italic" transform="scale(1,-1)" font-size="884px" font-family="serif" font-style="italic">发</text></g><g data-mml-node="mi" transform="translate(4933.6,0)"><text data-variant="italic" transform="scale(1,-1)" font-size="884px" font-family="serif" font-style="italic">送</text></g><g data-mml-node="mi" transform="translate(5833.6,0)"><text data-variant="italic" transform="scale(1,-1)" font-size="884px" font-family="serif" font-style="italic">时</text></g><g data-mml-node="mi" transform="translate(6733.6,0)"><text data-variant="italic" transform="scale(1,-1)" font-size="884px" font-family="serif" font-style="italic">延</text></g><g data-mml-node="mo" transform="translate(7855.8,0)"><path data-c="2B" d="M56 237T56 250T70 270H369V420L370 570Q380 583 389 583Q402 583 409 568V270H707Q722 262 722 250T707 230H409V-68Q401 -82 391 -82H389H387Q375 -82 369 -68V230H70Q56 237 56 250Z"></path></g><g data-mml-node="mi" transform="translate(8856,0)"><text data-variant="italic" transform="scale(1,-1)" font-size="884px" font-family="serif" font-style="italic">传</text></g><g data-mml-node="mi" transform="translate(9756,0)"><text data-variant="italic" transform="scale(1,-1)" font-size="884px" font-family="serif" font-style="italic">播</text></g><g data-mml-node="mi" transform="translate(10656,0)"><text data-variant="italic" transform="scale(1,-1)" font-size="884px" font-family="serif" font-style="italic">时</text></g><g data-mml-node="mi" transform="translate(11556,0)"><text data-variant="italic" transform="scale(1,-1)" font-size="884px" font-family="serif" font-style="italic">延</text></g><g data-mml-node="mo" transform="translate(12678.2,0)"><path data-c="2B" d="M56 237T56 250T70 270H369V420L370 570Q380 583 389 583Q402 583 409 568V270H707Q722 262 722 250T707 230H409V-68Q401 -82 391 -82H389H387Q375 -82 369 -68V230H70Q56 237 56 250Z"></path></g><g data-mml-node="mi" transform="translate(13678.4,0)"><text data-variant="italic" transform="scale(1,-1)" font-size="884px" font-family="serif" font-style="italic">处</text></g><g data-mml-node="mi" transform="translate(14578.4,0)"><text data-variant="italic" transform="scale(1,-1)" font-size="884px" font-family="serif" font-style="italic">理</text></g><g data-mml-node="mi" transform="translate(15478.4,0)"><text data-variant="italic" transform="scale(1,-1)" font-size="884px" font-family="serif" font-style="italic">时</text></g><g data-mml-node="mi" transform="translate(16378.4,0)"><text data-variant="italic" transform="scale(1,-1)" font-size="884px" font-family="serif" font-style="italic">延</text></g><g data-mml-node="mo" transform="translate(17500.7,0)"><path data-c="2B" d="M56 237T56 250T70 270H369V420L370 570Q380 583 389 583Q402 583 409 568V270H707Q722 262 722 250T707 230H409V-68Q401 -82 391 -82H389H387Q375 -82 369 -68V230H70Q56 237 56 250Z"></path></g><g data-mml-node="mi" transform="translate(18500.9,0)"><text data-variant="italic" transform="scale(1,-1)" font-size="884px" font-family="serif" font-style="italic">排</text></g><g data-mml-node="mi" transform="translate(19400.9,0)"><text data-variant="italic" transform="scale(1,-1)" font-size="884px" font-family="serif" font-style="italic">队</text></g><g data-mml-node="mi" transform="translate(20300.9,0)"><text data-variant="italic" transform="scale(1,-1)" font-size="884px" font-family="serif" font-style="italic">时</text></g><g data-mml-node="mi" transform="translate(21200.9,0)"><text data-variant="italic" transform="scale(1,-1)" font-size="884px" font-family="serif" font-style="italic">延</text></g></g></g></svg></mjx-container></p><blockquote><ul><li><strong>时延带宽积：传播时延和带宽相乘，就得到了传播时延带宽积</strong></li></ul></blockquote><p><mjx-container class="MathJax" jax="SVG" display="true"><svg style="vertical-align: -0.452ex" xmlns="http://www.w3.org/2000/svg" width="27.552ex" height="2.149ex" role="img" focusable="false" viewBox="0 -750 12178 950"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="scale(1,-1)"><g data-mml-node="math"><g data-mml-node="mi"><text data-variant="italic" transform="scale(1,-1)" font-size="884px" font-family="serif" font-style="italic">时</text></g><g data-mml-node="mi" transform="translate(900,0)"><text data-variant="italic" transform="scale(1,-1)" font-size="884px" font-family="serif" font-style="italic">延</text></g><g data-mml-node="mi" transform="translate(1800,0)"><text data-variant="italic" transform="scale(1,-1)" font-size="884px" font-family="serif" font-style="italic">带</text></g><g data-mml-node="mi" transform="translate(2700,0)"><text data-variant="italic" transform="scale(1,-1)" font-size="884px" font-family="serif" font-style="italic">宽</text></g><g data-mml-node="mi" transform="translate(3600,0)"><text data-variant="italic" transform="scale(1,-1)" font-size="884px" font-family="serif" font-style="italic">积</text></g><g data-mml-node="mo" transform="translate(4777.8,0)"><path data-c="3D" d="M56 347Q56 360 70 367H707Q722 359 722 347Q722 336 708 328L390 327H72Q56 332 56 347ZM56 153Q56 168 72 173H708Q722 163 722 153Q722 140 707 133H70Q56 140 56 153Z"></path></g><g data-mml-node="mi" transform="translate(5833.6,0)"><text data-variant="italic" transform="scale(1,-1)" font-size="884px" font-family="serif" font-style="italic">传</text></g><g data-mml-node="mi" transform="translate(6733.6,0)"><text data-variant="italic" transform="scale(1,-1)" font-size="884px" font-family="serif" font-style="italic">播</text></g><g data-mml-node="mi" transform="translate(7633.6,0)"><text data-variant="italic" transform="scale(1,-1)" font-size="884px" font-family="serif" font-style="italic">时</text></g><g data-mml-node="mi" transform="translate(8533.6,0)"><text data-variant="italic" transform="scale(1,-1)" font-size="884px" font-family="serif" font-style="italic">延</text></g><g data-mml-node="mo" transform="translate(9655.8,0)"><path data-c="2217" d="M229 286Q216 420 216 436Q216 454 240 464Q241 464 245 464T251 465Q263 464 273 456T283 436Q283 419 277 356T270 286L328 328Q384 369 389 372T399 375Q412 375 423 365T435 338Q435 325 425 315Q420 312 357 282T289 250L355 219L425 184Q434 175 434 161Q434 146 425 136T401 125Q393 125 383 131T328 171L270 213Q283 79 283 63Q283 53 276 44T250 35Q231 35 224 44T216 63Q216 80 222 143T229 213L171 171Q115 130 110 127Q106 124 100 124Q87 124 76 134T64 161Q64 166 64 169T67 175T72 181T81 188T94 195T113 204T138 215T170 230T210 250L74 315Q65 324 65 338Q65 353 74 363T98 374Q106 374 116 368T171 328L229 286Z"></path></g><g data-mml-node="mi" transform="translate(10378,0)"><text data-variant="italic" transform="scale(1,-1)" font-size="884px" font-family="serif" font-style="italic">带</text></g><g data-mml-node="mi" transform="translate(11278,0)"><text data-variant="italic" transform="scale(1,-1)" font-size="884px" font-family="serif" font-style="italic">宽</text></g></g></g></svg></mjx-container></p><blockquote><ul><li><strong>往返时间RTT：往返时间 RTT(Round-Trip Time) 表示从发送方发送数据开始，到发送方收到来自接收方的确认(接收方收到数据后立即发送确认)，总共经历的时间，往返时间包括各中间结点的处理时延、排队时延以及转发数据时的发送时延。往返时间 RTT 与所发送的分组长度有关，数据块分组越长所需的往返时间越多</strong></li></ul></blockquote><ul><li><em><strong>计算机网络的非性能特征：费用、质量、标准化、可靠性、可扩展性和可升级性、易于管理和维护</strong></em></li></ul><hr><h2 id="2-1-1-3-计算机网络体系结构"><a href="#2-1-1-3-计算机网络体系结构" class="headerlink" title="2.1.1.3 计算机网络体系结构"></a>2.1.1.3 计算机网络体系结构</h2><p><strong>(1). OSI 参考模型</strong></p><ul><li><p><strong>OSI 参考模型是国际互联网标准化组织(International Standards Organizations ISO) 所定义的，它是为了使各层上的协议国际标准化而发展起来的。OSI 参考模型全称是开放系统互连参考模型(Open System Interconnection Reference Model)。这一参考模型共分为七层：物理层(Physical)、数据链路层(Data Link)、网络层(Network)、传输层(Transport)、会话层(Session)、表示层(Presentation)和应用层(Application)</strong></p></li><li><p><strong>OSI 参考模型把对等层次之间传送的数据单位称为该层次的协议数据单元PDU(Protocol Data Unit)</strong></p></li><li><p><strong>OSI 模型共有七层</strong></p><ul><li><strong>物理层(physical layer)：在物理层上所传数据的单位是比特，物理层的任务是透明地传送比特流</strong></li><li><strong>数据链路层(data link layer)：简称链路层，数据链路层负责实现通信信道的无差错传输，将数据封装成帧，差错控制、流量控制和链路控制</strong></li><li><strong>网络层(network layer)：负责将数据正确迅速的从源点主机传送到目的点主机，其功能主要有寻址以及与相关的流量控制和拥塞控制等，TCP/IP 体系中，网络层使用 IP 协议</strong></li><li><strong>传输层(transport layer)：为上层处理过程掩盖下层结构的细节，保证把会话层的信息有效传送到另一方的会话层传输层有复用和分用的功能，传输层主要有两种协议：传输控制协议 TCP(Transmission Control Protocol)——面向连接的，用户数据报协议UDP(User Datagram Protocol)——面向连接的</strong></li><li><strong>会话层(Session layer)：它提供服务请求者和提供者之间的通讯，用于实现两端主机之间的会话管理，传输同步和活动管理等</strong></li><li><strong>表示层(Presentation layer)：它的主要功能是实现信息转换，包括压缩、加密、代码转换以及上述操作的逆操作等</strong></li><li><strong>应用层(application layer)：应用层是体系结构中的最高层，直接为用户的应用进程提供服务</strong></li></ul></li><li><p><strong>TCP/IP 参考模型</strong></p><ul><li><p><strong>TCP/IP 参考模型是首先由 ARPANET 所使用的网络体系结构。这个体系结构在它的两个主要协议出现以后被称为 TCP/IP 参考模型(TCP/IP Reference Model)。这一网络协议共分为四层：数据链路层、网络层、传输层和应用层</strong></p></li><li><p><strong>OSI 参考模型和 TCP/IP 参考模型都采用了层次结构的概念，都能够提供面向连接和无连接两种通信服务机制。TCP/IP 与 OSI 在分层模块上稍有区别。OSI 模型是在协议开发前设计的，具有通用性，TCP/IP是先有协议集然后建立模型，不适用于非TCP/IP网络；OSI参考模型的抽象能力高，适合与描述各种网络，而TCP/IP是先有了协议，才制定TCP/IP模型的；OSI 参考模型的概念划分清晰，但过于复杂，而 TCP/IP 参考模型在服务、接口和协议的区别上不清楚，功能描述和实现细节混在一起</strong><br><img src="2.1.1.%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84.png" alt="计算机网络体系结构" title="嘉措一郎(Gyatso Ichiro)"></p></li></ul></li><li><p><strong>网络协议的三要素</strong></p><ul><li><p><strong>语法：即数据与控制信息的结构或格式</strong></p></li><li><p><strong>语义：即需要发出何种控制信息，完成何种动作以及做出何种响应</strong></p></li><li><p><strong>同步：即事件实现顺序的详细说明</strong></p></li></ul></li></ul><hr><h2 id="2-1-1-4-Linux-TCP-IP-网络编程基础"><a href="#2-1-1-4-Linux-TCP-IP-网络编程基础" class="headerlink" title="2.1.1.4 Linux TCP/IP 网络编程基础"></a>2.1.1.4 Linux TCP/IP 网络编程基础</h2><p><strong>Linux 网络基础</strong></p><ul><li><p><strong>本地回环：固定 IP 地址，127.0.0.1</strong></p></li><li><p><strong>查看 IP 地址：ifconfig</strong></p><ul><li><p><strong>Hwaddr：网卡地址(物理地址、硬件地址)</strong></p></li><li><p><strong>inet addr：IP 地址</strong></p></li><li><p><strong>Bcast：广播地址</strong></p></li><li><p><strong>Mask：子网掩码</strong></p></li><li><p><strong>MTU：Max Transmission Unit 最大传输单元，即数据帧最大长度</strong></p></li><li><p><strong>Metric：路由长度</strong></p></li><li><p><strong>TX packets：发送的数据包总数、错误数、遗失数以及溢出数</strong></p></li><li><p><strong>RX packets：接收的数据包总数、错误数、遗失数以及溢出数</strong></p></li></ul></li><li><p><strong>设置 IP 地址相关信息</strong></p><ul><li><p><strong>语法：ifconfig 接口 IP地址 [broadcast 广播地址 netmask 子网掩码]</strong></p></li><li><p><strong>例：</strong></p><ul><li><strong>ifconfig eth0 192.168.0.3</strong></li><li><strong>ifconfig eth0 192.168.0.5 broadcast</strong></li><li><strong>192.168.0.255 netmask 255.255.255.0</strong></li><li><strong>注意：ifconfig 命令设置的 IP 地址不能永久保存，重启设备之后会丢失</strong></li></ul></li><li><p><strong>netconfig 命令设置网络参数</strong></p></li><li><p><strong>注意：netconfig 设置的网络配置信息可以永久保存到配置文件中，但不会立即生效，刷新方法：/etc/init.d/network restart</strong></p></li></ul></li><li><p><strong>网络配置相关文件</strong></p><ul><li><p><strong>/etc/sysconfig/network</strong></p><ul><li><strong>HOSTNAME：主机名设置</strong></li><li><strong>GATEWAY：默认网关设置</strong></li></ul></li><li><p><strong>/etc/sysconfig/network-scripts/ifcfg-eth0</strong></p><ul><li><strong>DEVICE：设备名称</strong></li><li><strong>BOOTPROTO：IP 地址设置方式(动态或静态)</strong></li><li><strong>BROADCAST：广播地址</strong></li><li><strong>HWADDR：硬件地址</strong></li><li><strong>IPADDR：IP 地址设置</strong></li><li><strong>NETMASK：子网掩码设置</strong></li><li><strong>NETWORK：网络地址</strong></li><li><strong>ONBOOT：启动时是否激活</strong></li></ul></li><li><p><strong>/etc/resolv.conf：DNS 服务器地址配置</strong></p></li></ul></li><li><p><strong>TCP 和 UDP</strong></p><ul><li><p><strong>TCP/IP 中有两个具有代表性的传输层协议，TCP 和 UDP</strong></p></li><li><p><strong>TCP(Transimision Control Protocal)：传输控制协议，是面向连接的、可靠的协议</strong></p></li><li><p><strong>UDP(User Datagram Protocal)：用户数据报协议，是不具有可靠性的数据报协议</strong></p></li><li><p><strong>IP(Internet Protocol)：网际协议是网络层协议</strong></p></li></ul></li></ul><hr><h2 id="2-1-1-5-协议簇"><a href="#2-1-1-5-协议簇" class="headerlink" title="2.1.1.5 协议簇"></a>2.1.1.5 协议簇</h2><ul><li><p><strong>TCP - 传输控制协议</strong></p><ul><li><strong>TCP 用于从应用程序到网络的数据传输控制</strong></li><li><strong>TCP 负责在数据传送之前将它们分割为 IP 包，然后在它们到达的时候将它们重组</strong></li></ul></li><li><p><strong>IP - 网际协议(Internet Protocol)</strong></p><ul><li><strong>IP 负责计算机之间的通信</strong></li><li><strong>IP 负责在因特网上发送和接收数据包</strong></li></ul></li><li><p><strong>HTTP - 超文本传输协议(Hyper Text Transfer Protocol)</strong></p><ul><li><strong>HTTP 负责 web 服务器与 web 浏览器之间的通信</strong></li><li><strong>HTTP 用于从 web 客户端(浏览器)向 web 服务器发送请求，并从 web 服务器向 web 客户端返回内容(网页)</strong></li></ul></li><li><p><strong>HTTPS - 安全的 HTTP(HTTP Secure)</strong></p><ul><li><strong>HTTPS 负责在 web 服务器和 web 浏览器之间的安全通信</strong></li><li><strong>作为有代表性的应用，HTTPS 会用于处理信用卡交易和其他的敏感数据</strong></li></ul></li><li><p><strong>SSL - 安全套接字层(Secure Sockets Layer)</strong></p><ul><li><strong>SSL 协议用于为安全数据传输加密数据</strong></li></ul></li><li><p><strong>SMTP - 简易邮件传输协议(Simple Mail Transfer Protocol)</strong></p><ul><li><strong>SMTP 用于电子邮件的传输</strong></li></ul></li><li><p><strong>MIME - 多用途因特网邮件扩展(Multi-purpose Internet Mail Extensions)</strong></p><ul><li><strong>MIME 协议使 SMTP 有能力通过 TCP/IP 网络传输多媒体文件，包括声音、视频和二进制数据</strong></li></ul></li><li><p><strong>IMAP - 因特网消息访问协议(Internet Message Access Protocol)</strong></p><ul><li><strong>IMAP 用于存储和取回电子邮件</strong></li></ul></li><li><p><strong>POP - 邮局协议(Post Office Protocol)</strong></p><ul><li><strong>POP 用于从电子邮件服务器向个人电脑下载电子邮件</strong></li></ul></li><li><p><strong>FTP - 文件传输协议(File Transfer Protocol)</strong></p><ul><li><strong>FTP 负责计算机之间的文件传输</strong></li></ul></li><li><p><strong>NTP - 网络时间协议(Network Time Protocol)</strong></p><ul><li><strong>NTP 用于在计算机之间同步时间（钟）</strong></li></ul></li><li><p><strong>DHCP - 动态主机配置协议(Dynamic Host Configuration Protocol)</strong></p><ul><li><strong>DHCP 用于向网络中的计算机分配动态 IP 地址</strong></li></ul></li><li><p><strong>SNMP - 简单网络管理协议(Simple Network Management Protocol)</strong></p><ul><li><strong>SNMP 用于计算机网络的管理</strong></li></ul></li><li><p><strong>LDAP - 轻量级的目录访问协议(Lightweight Directory Access Protocol)</strong></p><ul><li><strong>LDAP 用于从因特网搜集关于用户和电子邮件地址的信息</strong></li></ul></li><li><p><strong>ICMP - 因特网消息控制协议(Internet Control Message Protocol)</strong></p><ul><li><strong>ICMP 负责网络中的错误处理</strong></li></ul></li><li><p><strong>ARP - 地址解析协议(Address Resolution Protocol)</strong></p><ul><li><strong>ARP - 用于通过 IP 来查找基于 IP 地址的计算机网卡的硬件地址</strong></li></ul></li><li><p><strong>RARP - 反向地址转换协议(Reverse Address Resolution Protocol)</strong></p><ul><li><strong>RARP 用于通过 IP 查找基于硬件地址的计算机网卡的 IP 地址</strong></li></ul></li><li><p><strong>BOOTP - 自举协议(Boot Protocol)</strong></p><ul><li><strong>BOOTP 用于从网络启动计算机</strong></li></ul></li><li><p><strong>PPTP - 点对点隧道协议(Point to Point Tunneling Protocol)</strong></p><ul><li><strong>PPTP 用于私人网络之间的连接(隧道)</strong></li></ul></li></ul><hr><h2 id="2-1-1-6-socket-系统调用"><a href="#2-1-1-6-socket-系统调用" class="headerlink" title="2.1.1.6 socket() 系统调用"></a>2.1.1.6 socket() 系统调用</h2><p><strong>socket() 套接字是一套网络编程接口函数集的总称，在 Linux 中网络编程是通过 socket() 接口来进行的，socket 是网络 I/O，套接字也是文件描述符，是Linux跨进程间通信(IPC，Inter Process Communication)方式的一种</strong></p><p><strong>Socket根据通信协议的不同还可以分为3种：流式套接字(SOCK_STREAM)，数据报套接字(SOCK_DGRAM)及原始套接字。</strong></p><p><strong><code>流式套接字(SOCK_STREAM)：最常见的套接字，使用TCP协议，提供可靠的、面向连接的通信流。保证数据传输是正确的，并且是顺序的。应用于Telnet远程连接、WWW服务等。</code></strong></p><p><strong><code>数据报套接字(SOCK_DGRAM)：使用UDP协议，提供无连接的服务，数据通过相互独立的报文进行传输，是无序的，并且不保证可靠性。使用UDP的应用程序要有自己的对数据进行确认的协议。</code></strong></p><p><strong><code>原始套接字：允许对低层协议如IP或ICMP直接访问，主要用于新的网络协议实现的测试等。原始套接字主要用于一些协议的开发，可以进行比较底层的操作。它功能强大，但是没有上面介绍的两种套接字使用方便，一般的程序也涉及不到原始套接字。</code></strong></p><p><strong>(1) socket 创建套接字</strong></p><ul><li><strong>函数原型</strong></li></ul><blockquote><p><strong>socket() 系统调用创建一个新的套接字，即创建通信端点，返回一个套接字文件描述符 sockfd</strong></p></blockquote><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">NAME</span><br><span class="line">       socket - create an endpoint <span class="keyword">for</span> communication</span><br><span class="line"></span><br><span class="line">SYNOPSIS</span><br><span class="line">       <span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/types.h&gt;</span>          <span class="comment">/* See NOTES */</span></span></span><br><span class="line">       <span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/socket.h&gt;</span></span></span><br><span class="line"></span><br><span class="line">       <span class="function"><span class="keyword">int</span> <span class="title">socket</span><span class="params">(<span class="keyword">int</span> domain, <span class="keyword">int</span> type, <span class="keyword">int</span> protocol)</span></span>;</span><br><span class="line"></span><br></pre></td></tr></table></figure><ul><li><p><strong>函数参数</strong></p><ul><li><p><strong>domain：指定网域， AF_INET IPv4， AF_INET6 IPv6</strong></p></li><li><p><strong>type：选择传输协议族， SOCK_STREAM TCP， SOCK_DGRAM UDP</strong></p></li><li><p><strong>protocol：基本废弃，直接赋0</strong></p></li></ul></li><li><p><strong>返回值：成功返回网络套接字描述符 sockfd，失败返回 -1</strong></p></li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;netinet/in.h&gt;</span></span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in</span></span></span><br><span class="line"><span class="class">{</span></span><br><span class="line"><span class="keyword">unsigned</span> <span class="keyword">short</span> sin_family;  地址族</span><br><span class="line"><span class="keyword">unsigned</span> <span class="keyword">short</span> sin_port;    端口号</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">in_addr</span> <span class="title">sin_addr</span>;</span>    IP地址</span><br><span class="line"><span class="keyword">char</span> sin_zero[<span class="number">8</span>];           未使用</span><br><span class="line">};</span><br><span class="line"></span><br></pre></td></tr></table></figure><p><strong>(2) bind() 向 sockfd 绑定端口号和 IP 地址</strong></p><ul><li><strong>函数原型</strong></li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">NAME</span><br><span class="line">       bind - bind a name to a socket</span><br><span class="line"></span><br><span class="line">SYNOPSIS</span><br><span class="line">       <span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/types.h&gt;</span>          <span class="comment">/* See NOTES */</span></span></span><br><span class="line">       <span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/socket.h&gt;</span></span></span><br><span class="line"></span><br><span class="line">       <span class="function"><span class="keyword">int</span> <span class="title">bind</span><span class="params">(<span class="keyword">int</span> sockfd, <span class="keyword">const</span> struct sockaddr *addr,</span></span></span><br><span class="line"><span class="params"><span class="function">                <span class="keyword">socklen_t</span> addrlen)</span></span>;</span><br><span class="line"></span><br></pre></td></tr></table></figure><ul><li><p><strong>函数参数</strong></p><ul><li><p><strong>sockfd：为 socket() 函数的返回值</strong></p></li><li><p><strong>addr：封装IP地址和端口号</strong></p></li><li><p><strong>addrlen：struct sockaddr 结构体的大小，sizeof(struct sockaddr)</strong></p></li></ul></li><li><p><strong>返回值：成功返回 0，失败返回 -1</strong></p></li></ul><p><strong>(3) listen() 监听套接字上的连接，设置允许的最大连接数</strong></p><ul><li><strong>函数原型</strong></li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">NAME</span><br><span class="line">       listen - listen <span class="keyword">for</span> connections on a socket</span><br><span class="line"></span><br><span class="line">SYNOPSIS</span><br><span class="line">       <span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/types.h&gt;</span>          <span class="comment">/* See NOTES */</span></span></span><br><span class="line">       <span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/socket.h&gt;</span></span></span><br><span class="line"></span><br><span class="line">       <span class="function"><span class="keyword">int</span> <span class="title">listen</span><span class="params">(<span class="keyword">int</span> sockfd, <span class="keyword">int</span> backlog)</span></span>;</span><br><span class="line"></span><br></pre></td></tr></table></figure><ul><li><p><strong>函数参数</strong></p><ul><li><p><strong>sockfd：为 socket() 函数的返回值</strong></p></li><li><p><strong>backlog：指定同时能处理的最大连接要求(即队列的最大长度)，通常为10或者5，最大为128</strong></p></li></ul></li><li><p><strong>返回值：成功返回 0，失败返回 -1</strong></p></li></ul><p><strong>(4) accept() 等待来自客户端的连接请求</strong></p><ul><li><strong>函数原型</strong></li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">NAME</span><br><span class="line">       accept, accept4 - accept a connection on a socket</span><br><span class="line"></span><br><span class="line">SYNOPSIS</span><br><span class="line">       <span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/types.h&gt;</span>          <span class="comment">/* See NOTES */</span></span></span><br><span class="line">       <span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/socket.h&gt;</span></span></span><br><span class="line"></span><br><span class="line">       <span class="function"><span class="keyword">int</span> <span class="title">accept</span><span class="params">(<span class="keyword">int</span> sockfd, struct sockaddr *addr, <span class="keyword">socklen_t</span> *addrlen)</span></span>;</span><br><span class="line"></span><br></pre></td></tr></table></figure><ul><li><p><strong>函数参数</strong></p><ul><li><p><strong>sockfd：为 socket() 函数的返回值</strong></p></li><li><p><strong>addr：用于接收客户端的 IP 地址和端口号</strong></p></li><li><p><strong>addrlen：struct sockaddr <code>*</code>addr 的大小</strong></p></li></ul></li><li><p><strong>返回值：返回新的套接字描述符(通信套接字)，专门用于与建立客户端的通信，失败返回 -1</strong></p></li></ul><p><strong>send() 在套接字上发送消息</strong></p><ul><li><strong>函数原型</strong></li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">NAME</span><br><span class="line">       send, sendto, sendmsg - send a message on a socket</span><br><span class="line"></span><br><span class="line">SYNOPSIS</span><br><span class="line">       <span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/types.h&gt;</span></span></span><br><span class="line">       <span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/socket.h&gt;</span></span></span><br><span class="line"></span><br><span class="line">       <span class="function"><span class="keyword">ssize_t</span> <span class="title">send</span><span class="params">(<span class="keyword">int</span> sockfd, <span class="keyword">const</span> <span class="keyword">void</span> *buf, <span class="keyword">size_t</span> len, <span class="keyword">int</span> flags)</span></span>;</span><br><span class="line"></span><br><span class="line">       <span class="function"><span class="keyword">ssize_t</span> <span class="title">sendto</span><span class="params">(<span class="keyword">int</span> sockfd, <span class="keyword">const</span> <span class="keyword">void</span> *buf, <span class="keyword">size_t</span> len, <span class="keyword">int</span> flags,</span></span></span><br><span class="line"><span class="params"><span class="function">                      <span class="keyword">const</span> struct sockaddr *dest_addr, <span class="keyword">socklen_t</span> addrlen)</span></span>;</span><br><span class="line"></span><br><span class="line">       <span class="function"><span class="keyword">ssize_t</span> <span class="title">sendmsg</span><span class="params">(<span class="keyword">int</span> sockfd, <span class="keyword">const</span> struct msghdr *msg, <span class="keyword">int</span> flags)</span></span>;</span><br><span class="line"></span><br></pre></td></tr></table></figure><ul><li><p><strong>函数参数</strong></p><ul><li><p><strong>sockfd：为 accept() 函数的返回值</strong></p></li><li><p><strong>buf：要发送的数据缓冲区</strong></p></li><li><p><strong>len：buf的数据长度</strong></p></li><li><p><strong>flags：一般赋为 0，阻塞</strong></p></li><li><p><strong>dest_addr：服务器的 IP 和端口号</strong></p></li><li><p><strong>addrlen：dest_addr 结构体指针的长度</strong></p></li></ul></li><li><p><strong>返回值：成功返回数据长度，失败 -1</strong></p></li></ul><p><strong>recv() 从套接字接收消息</strong></p><ul><li><strong>函数原型</strong></li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">NAME</span><br><span class="line">       recv, recvfrom, recvmsg - receive a message from a socket</span><br><span class="line"></span><br><span class="line">SYNOPSIS</span><br><span class="line">       <span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/types.h&gt;</span></span></span><br><span class="line">       <span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/socket.h&gt;</span></span></span><br><span class="line"></span><br><span class="line">       <span class="function"><span class="keyword">ssize_t</span> <span class="title">recv</span><span class="params">(<span class="keyword">int</span> sockfd, <span class="keyword">void</span> *buf, <span class="keyword">size_t</span> len, <span class="keyword">int</span> flags)</span></span>;</span><br><span class="line"></span><br><span class="line">       <span class="function"><span class="keyword">ssize_t</span> <span class="title">recvfrom</span><span class="params">(<span class="keyword">int</span> sockfd, <span class="keyword">void</span> *buf, <span class="keyword">size_t</span> len, <span class="keyword">int</span> flags,</span></span></span><br><span class="line"><span class="params"><span class="function">                        struct sockaddr *src_addr, <span class="keyword">socklen_t</span> *addrlen)</span></span>;</span><br><span class="line"></span><br><span class="line">       <span class="function"><span class="keyword">ssize_t</span> <span class="title">recvmsg</span><span class="params">(<span class="keyword">int</span> sockfd, struct msghdr *msg, <span class="keyword">int</span> flags)</span></span>;</span><br><span class="line"></span><br></pre></td></tr></table></figure><ul><li><p><strong>函数参数</strong></p><ul><li><p><strong>sockfd：为 accept() 函数的返回值</strong></p></li><li><p><strong>buf：存放接收数据的缓冲区</strong></p></li><li><p><strong>len：数据缓冲区大小</strong></p></li><li><p><strong>flags：一般赋为 0，阻塞</strong></p></li><li><p><strong>src_addr：源机地址和端口号</strong></p></li><li><p><strong>addrlen：地址长度</strong></p></li></ul></li><li><p><strong>返回值：成功返回接收到数据的长度，失败 -1</strong></p></li></ul><p><strong>connect() 客户端用来请求连接远程服务器</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">NAME</span><br><span class="line">       connect - initiate a connection on a socket</span><br><span class="line"></span><br><span class="line">SYNOPSIS</span><br><span class="line">       <span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/types.h&gt;</span>          <span class="comment">/* See NOTES */</span></span></span><br><span class="line">       <span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/socket.h&gt;</span></span></span><br><span class="line"></span><br><span class="line">       <span class="function"><span class="keyword">int</span> <span class="title">connect</span><span class="params">(<span class="keyword">int</span> sockfd, <span class="keyword">const</span> struct sockaddr *addr,</span></span></span><br><span class="line"><span class="params"><span class="function">                   <span class="keyword">socklen_t</span> addrlen)</span></span>;</span><br><span class="line"></span><br></pre></td></tr></table></figure><ul><li><p><strong>函数参数</strong></p><ul><li><p><strong>sockfd：为 socket() 函数的返回值</strong></p></li><li><p><strong>addr：为结构体变量指针，存放远程服务器的 IP 与端口号信息</strong></p></li><li><p><strong>addrlen：addr 结构体变量的长度</strong></p></li></ul></li><li><p><strong>返回值：成功返回 0，失败 -1</strong></p></li></ul><hr><h2 id="2-1-1-7-TCP-Server-和-TCP-Client-编程"><a href="#2-1-1-7-TCP-Server-和-TCP-Client-编程" class="headerlink" title="2.1.1.7 TCP Server 和 TCP Client 编程"></a>2.1.1.7 TCP Server 和 TCP Client 编程</h2><ul><li><p><strong>TCP协议编程框架</strong><br><img src="2.1.2.TCP%E5%8D%8F%E8%AE%AE%E7%BC%96%E7%A8%8B%E6%A1%86%E6%9E%B6.jpg" alt="TCP协议编程框架" title="嘉措一郎(Gyatso Ichiro)"></p></li><li><p><strong>TCP Server</strong></p></li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">/*  单客户端连接  */</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">tcp_server</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line"><span class="keyword">char</span> recvmsg[TCP_SERVER_BUFF_SIZE] = { <span class="string">'\0'</span> };  <span class="comment">/*  服务器端接收数据缓冲区  */</span></span><br><span class="line"><span class="keyword">char</span> sendmsg[TCP_SERVER_BUFF_SIZE] = { <span class="string">'\0'</span> };  <span class="comment">/*  服务器端发送数据缓冲区  */</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*  创建套接字 sockfd  */</span></span><br><span class="line"><span class="keyword">int</span> sockfd = <span class="built_in">socket</span>(AF_INET, SOCK_STREAM, <span class="number">0</span>);</span><br><span class="line"><span class="keyword">if</span> (<span class="number">-1</span> == sockfd)</span><br><span class="line">{</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"[TCP Server]: Create a socket file descriptor error\n"</span>);</span><br><span class="line"><span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">}</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"[TCP Server]: Create a socket file descriptor succeed\n"</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">/*  填充数据结构体  struct sockaddr_in  */</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in</span> <span class="title">seraddr</span>;</span></span><br><span class="line"><span class="built_in">memset</span>(&amp;seraddr, <span class="number">0</span>, <span class="built_in"><span class="keyword">sizeof</span></span>(seraddr));</span><br><span class="line">seraddr.sin_family = AF_INET;                   <span class="comment">/*  地址族：IPv4  */</span></span><br><span class="line">seraddr.sin_port = <span class="built_in">htons</span>(TCP_SERVER_PORT);      <span class="comment">/*  端口号  */</span></span><br><span class="line">seraddr.sin_addr.s_addr = <span class="built_in">htonl</span>(TCP_SERVER_IP); <span class="comment">/*  IP地址  */</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*  绑定端口号和IP地址到套接字 sockfd  */</span></span><br><span class="line"><span class="keyword">if</span> (<span class="number">-1</span> == <span class="built_in">bind</span>(sockfd, (struct sockaddr*)&amp;seraddr, <span class="built_in"><span class="keyword">sizeof</span></span>(seraddr)))</span><br><span class="line">{</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"[TCP Server]: Bind a server IP addr  and port to sockfd error\n"</span>);</span><br><span class="line"><span class="keyword">return</span> <span class="number">-2</span>;</span><br><span class="line">}</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"[TCP Server]: Bind a server IP addr  and port to sockfd succeed\n"</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">/*  开始监听，设置最大链接数  */</span></span><br><span class="line"><span class="keyword">if</span> (<span class="number">-1</span> == <span class="built_in">listen</span>(sockfd, TCP_SERVER_BACKLOG))</span><br><span class="line">{</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"[TCP Server]: Listen for connections on a sockfd error\n"</span>);</span><br><span class="line"><span class="keyword">return</span> <span class="number">-3</span>;</span><br><span class="line">}</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"[TCP Server]: Listen for connections on a sockfd succeed\n"</span>);</span><br><span class="line"></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"[TCP Server]: Waiting for client's link request\n"</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">/*  等待来自客户端的连接请求  */</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in</span> <span class="title">cliaddr</span>;</span></span><br><span class="line"><span class="built_in">memset</span>(&amp;cliaddr, <span class="number">0</span>, <span class="built_in"><span class="keyword">sizeof</span></span>(cliaddr));</span><br><span class="line"><span class="keyword">socklen_t</span> cliaddrlen = <span class="built_in"><span class="keyword">sizeof</span></span>(cliaddr);</span><br><span class="line"><span class="keyword">int</span> clifd = <span class="built_in">accept</span>(sockfd, (struct sockaddr*)&amp;cliaddr, &amp;cliaddrlen);</span><br><span class="line"><span class="keyword">if</span> (<span class="number">-1</span> == clifd)</span><br><span class="line">{</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"[TCP Server]: Accept a connection on a clifd error\n"</span>);</span><br><span class="line"><span class="keyword">return</span> <span class="number">-4</span>;</span><br><span class="line">}</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"[TCP Server]: Accept a connection on a clifd succeed\n"</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span> (<span class="number">1</span>)</span><br><span class="line">{</span><br><span class="line"><span class="built_in">bzero</span>(recvmsg, TCP_SERVER_BUFF_SIZE);</span><br><span class="line"><span class="keyword">ssize_t</span> reclen = <span class="built_in">recv</span>(clifd, recvmsg, TCP_SERVER_BUFF_SIZE, <span class="number">0</span>);</span><br><span class="line"><span class="keyword">if</span> (reclen &gt; <span class="number">0</span>)</span><br><span class="line">{</span><br><span class="line">recvmsg[reclen] = <span class="string">'\0'</span>;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"[TCP Server]: From %s client message: (%s)\n"</span>, <span class="built_in">inet_ntoa</span>(cliaddr.sin_addr), recvmsg);</span><br><span class="line"></span><br><span class="line"><span class="built_in">strcpy</span>(sendmsg, recvmsg);</span><br><span class="line"><span class="built_in">send</span>(clifd, sendmsg, <span class="built_in">strlen</span>(sendmsg) + <span class="number">1</span>, <span class="number">0</span>);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"[TCP Server]: To client send message: (%s)\n"</span>, <span class="built_in">inet_ntoa</span>(cliaddr.sin_addr));</span><br><span class="line"><span class="keyword">if</span> (<span class="number">0</span> == <span class="built_in">strncmp</span>(<span class="string">"exit"</span>, recvmsg, <span class="number">4</span>))</span><br><span class="line">{</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">}</span><br><span class="line">}</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">{</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">}</span><br><span class="line">}</span><br><span class="line"><span class="built_in">close</span>(clifd);</span><br><span class="line"><span class="built_in">close</span>(sockfd);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"[TCP Server]: Close\n"</span>);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br><span class="line"></span><br></pre></td></tr></table></figure><ul><li><strong>TCP Client</strong></li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">/*  TCP 客户端程序  */</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">tcp_client</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line"><span class="keyword">char</span> recvmsg[TCP_CLIENT_BUFF_SIZE] = { <span class="string">'\0'</span> };      <span class="comment">/*  客户端接收数据缓冲区  */</span></span><br><span class="line"><span class="keyword">char</span> sendmsg[TCP_CLIENT_BUFF_SIZE] = { <span class="string">'\0'</span> };      <span class="comment">/*  客户端发送数据缓冲区  */</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*  创建套接字 sockfd  */</span></span><br><span class="line"><span class="keyword">int</span> sockfd = <span class="built_in">socket</span>(AF_INET, SOCK_STREAM, <span class="number">0</span>);</span><br><span class="line"><span class="keyword">if</span> (<span class="number">-1</span> == sockfd)</span><br><span class="line">{</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"[TCP Client]: Create a socket file descriptor error\n"</span>);</span><br><span class="line"><span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">}</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"[TCP Client]: Create a socket file descriptor succeed\n"</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">/*  填充数据结构体  struct sockaddr_in  */</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in</span> <span class="title">cliaddr</span>;</span></span><br><span class="line"><span class="built_in">memset</span>(&amp;cliaddr, <span class="number">0</span>, <span class="built_in"><span class="keyword">sizeof</span></span>(cliaddr));</span><br><span class="line">cliaddr.sin_family = AF_INET;                       <span class="comment">/*  地址族：IPv4  */</span></span><br><span class="line">cliaddr.sin_port = <span class="built_in">htons</span>(TCP_CLIENT_PORT);          <span class="comment">/*  端口号，主机 -&gt; 网络，将无符号短整型的主机端口数值转换成网络字节序  */</span></span><br><span class="line">cliaddr.sin_addr.s_addr = <span class="built_in">inet_addr</span>(TCP_CLIENT_IP); <span class="comment">/*  IP地址，inet_addr 函数将 IP 地址转换成 32 位的二进制网络字节序地址  */</span></span><br><span class="line">    </span><br><span class="line"><span class="comment">/*  与服务器建立连接  */</span></span><br><span class="line"><span class="keyword">if</span> (<span class="number">-1</span> == <span class="built_in">connect</span>(sockfd, (struct sockaddr*)&amp;cliaddr, <span class="built_in"><span class="keyword">sizeof</span></span>(cliaddr)))</span><br><span class="line">{</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"[TCP Client]: Connection or binding error\n"</span>);</span><br><span class="line"><span class="keyword">return</span> <span class="number">-2</span>;</span><br><span class="line">}</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"[TCP Client]: Connection or binding succeed\n"</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">ssize_t</span> sendlen;</span><br><span class="line"><span class="keyword">ssize_t</span> recvlen;</span><br><span class="line"><span class="built_in">memset</span>(&amp;sendlen, <span class="number">0</span>, <span class="built_in"><span class="keyword">sizeof</span></span>(<span class="keyword">ssize_t</span>));</span><br><span class="line"><span class="built_in">memset</span>(&amp;recvlen, <span class="number">0</span>, <span class="built_in"><span class="keyword">sizeof</span></span>(<span class="keyword">ssize_t</span>));</span><br><span class="line"><span class="built_in">strcpy</span>(sendmsg, <span class="string">"Hello Server,I'm client"</span>);</span><br><span class="line"><span class="keyword">while</span> (<span class="number">1</span>)</span><br><span class="line">{</span><br><span class="line">sendlen = <span class="built_in">send</span>(sockfd, sendmsg, <span class="built_in">strlen</span>(sendmsg) + <span class="number">1</span>, <span class="number">0</span>);</span><br><span class="line"><span class="keyword">if</span> (sendlen &gt; <span class="number">0</span>)</span><br><span class="line">{</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"[TCP Client]: Send to server message: (%s)\n"</span>, sendmsg);</span><br><span class="line"><span class="built_in">bzero</span>(recvmsg, TCP_CLIENT_BUFF_SIZE);</span><br><span class="line">recvlen = <span class="built_in">recv</span>(sockfd, recvmsg, TCP_CLIENT_BUFF_SIZE, <span class="number">0</span>);</span><br><span class="line"><span class="keyword">if</span> (recvlen &gt; <span class="number">0</span>)</span><br><span class="line">{</span><br><span class="line">recvmsg[recvlen] = <span class="string">'\0'</span>;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"[TCP Client]: Recv from server message: (%s)\n"</span>, recvmsg);</span><br><span class="line">}</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">{</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">}</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">{</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">}</span><br><span class="line"><span class="built_in">sleep</span>(<span class="number">1</span>);</span><br><span class="line">}</span><br><span class="line"><span class="built_in">close</span>(sockfd);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"[TCP Client]: Close\n"</span>);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br><span class="line"></span><br></pre></td></tr></table></figure><ul><li><p><strong>UDP协议编程框架</strong><br><img src="2.1.3.UDP%E5%8D%8F%E8%AE%AE%E7%BC%96%E7%A8%8B%E6%A1%86%E6%9E%B6.jpg" alt="UDP协议编程框架" title="嘉措一郎(Gyatso Ichiro)"></p></li><li><p><strong>UDP Server</strong></p></li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">/*  UDP 服务器端程序  */</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">udp_server</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line"><span class="keyword">char</span> recvmsg[UDP_SERVER_BUFF_SIZE] = { <span class="string">'\0'</span> };      <span class="comment">/*  服务器端接收数据缓冲区  */</span></span><br><span class="line"><span class="keyword">char</span> sendmsg[UDP_SERVER_BUFF_SIZE] = { <span class="string">'\0'</span> };      <span class="comment">/*  服务器端发送数据缓冲区  */</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*  创建套接字 sockfd  */</span></span><br><span class="line"><span class="keyword">int</span> sockfd = <span class="built_in">socket</span>(AF_INET, SOCK_DGRAM, <span class="number">0</span>);</span><br><span class="line"><span class="keyword">if</span> (<span class="number">-1</span> == sockfd)</span><br><span class="line">{</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"[UDP Server]: Create a socket file descriptor error\n"</span>);</span><br><span class="line"><span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">}</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"[UDP Server]: Create a socket file descriptor succeed\n"</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">/*  填充数据结构体  struct sockaddr_in  */</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in</span> <span class="title">seraddr</span>;</span></span><br><span class="line"><span class="built_in">memset</span>(&amp;seraddr, <span class="number">0</span>, <span class="built_in"><span class="keyword">sizeof</span></span>(seraddr));</span><br><span class="line">seraddr.sin_family = AF_INET;                       <span class="comment">/*  地址族：IPv4  */</span></span><br><span class="line">seraddr.sin_port = <span class="built_in">htons</span>(UDP_SERVER_PORT);          <span class="comment">/*  端口号  */</span></span><br><span class="line">seraddr.sin_addr.s_addr = <span class="built_in">htonl</span>(UDP_SERVER_IP);     <span class="comment">/*  IP地址  */</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*  绑定端口号和IP地址到套接字 sockfd  */</span></span><br><span class="line"><span class="keyword">if</span> (<span class="number">-1</span> == <span class="built_in">bind</span>(sockfd, (struct sockaddr*)&amp;seraddr, <span class="built_in"><span class="keyword">sizeof</span></span>(seraddr)))</span><br><span class="line">{</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"[UDP Server]: Bind a server IP addr  and port to sockfd error\n"</span>);</span><br><span class="line"><span class="keyword">return</span> <span class="number">-2</span>;</span><br><span class="line">}</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"[UDP Server]: Bind a server IP addr  and port to sockfd succeed\n"</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">socklen_t</span> serlen;</span><br><span class="line"><span class="keyword">ssize_t</span> reclen;</span><br><span class="line"><span class="built_in">memset</span>(&amp;serlen, <span class="number">0</span>, <span class="built_in"><span class="keyword">sizeof</span></span>(serlen));</span><br><span class="line"><span class="built_in">memset</span>(&amp;reclen, <span class="number">0</span>, <span class="built_in"><span class="keyword">sizeof</span></span>(reclen));</span><br><span class="line"><span class="keyword">while</span> (<span class="number">1</span>)</span><br><span class="line">{</span><br><span class="line"><span class="built_in">bzero</span>(recvmsg, UDP_SERVER_BUFF_SIZE);</span><br><span class="line">reclen = <span class="built_in">recvfrom</span>(sockfd, recvmsg, UDP_SERVER_BUFF_SIZE, <span class="number">0</span>, (struct sockaddr*)&amp;seraddr, &amp;serlen);</span><br><span class="line"><span class="keyword">if</span> (reclen &gt; <span class="number">0</span>)</span><br><span class="line">{</span><br><span class="line">recvmsg[reclen] = <span class="string">'\0'</span>;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"[UDP Server]: From %s client message: (%s)\n"</span>, <span class="built_in">inet_ntoa</span>(seraddr.sin_addr), recvmsg);</span><br><span class="line"></span><br><span class="line"><span class="built_in">strcpy</span>(sendmsg, recvmsg);</span><br><span class="line"><span class="built_in">sendto</span>(sockfd, sendmsg, <span class="built_in">strlen</span>(sendmsg) + <span class="number">1</span>, <span class="number">0</span>, (struct sockaddr*)&amp;seraddr, serlen);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"[UDP Server]: To client send message: (%s)\n"</span>, <span class="built_in">inet_ntoa</span>(seraddr.sin_addr));</span><br><span class="line">reclen = <span class="number">0</span>;</span><br><span class="line">}</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">{</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">}</span><br><span class="line">}</span><br><span class="line"><span class="built_in">close</span>(sockfd);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"[UDP Server]: Close\n"</span>);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br><span class="line"></span><br></pre></td></tr></table></figure><ul><li><strong>UDP Client</strong></li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">/*  UDP 客户端程序  */</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">udp_client</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line"><span class="keyword">char</span> recvmsg[UDP_CLIENT_BUFF_SIZE] = { <span class="string">'\0'</span> };          <span class="comment">/*  客户端接收数据缓冲区  */</span></span><br><span class="line"><span class="keyword">char</span> sendmsg[UDP_CLIENT_BUFF_SIZE] = { <span class="string">'\0'</span> };          <span class="comment">/*  客户端发送数据缓冲区  */</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*  创建套接字 sockfd，AF_INET：IPv4，SOCK_DGRAM：UDP  */</span></span><br><span class="line"><span class="keyword">int</span> sockfd = <span class="built_in">socket</span>(AF_INET, SOCK_DGRAM, <span class="number">0</span>);</span><br><span class="line"><span class="keyword">if</span> (<span class="number">-1</span> == sockfd)</span><br><span class="line">{</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"[UDP Client]: Create a socket file descriptor error\n"</span>);</span><br><span class="line"><span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">}</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"[UDP Client]: Create a socket file descriptor succeed\n"</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">/*  填充数据结构体  struct sockaddr_in  */</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in</span> <span class="title">cliaddr</span>;</span></span><br><span class="line"><span class="built_in">memset</span>(&amp;cliaddr, <span class="number">0</span>, <span class="built_in"><span class="keyword">sizeof</span></span>(cliaddr));</span><br><span class="line">cliaddr.sin_family = AF_INET;                           <span class="comment">/*  地址族：IPv4  */</span></span><br><span class="line">cliaddr.sin_port = <span class="built_in">htons</span>(UDP_CLIENT_PORT);              <span class="comment">/*  端口号，主机 -&gt; 网络，将无符号短整型的主机端口数值转换成网络字节序  */</span></span><br><span class="line">cliaddr.sin_addr.s_addr = <span class="built_in">inet_addr</span>(UDP_CLIENT_IP);     <span class="comment">/*  IP地址，inet_addr 函数将 IP 地址转换成 32 位的二进制网络字节序地址  */</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*  与服务器建立连接  */</span></span><br><span class="line"><span class="keyword">if</span> (<span class="number">-1</span> == <span class="built_in">connect</span>(sockfd, (struct sockaddr*)&amp;cliaddr, <span class="built_in"><span class="keyword">sizeof</span></span>(cliaddr)))</span><br><span class="line">{</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"[UDP Client]: Connection or binding error\n"</span>);</span><br><span class="line"><span class="keyword">return</span> <span class="number">-2</span>;</span><br><span class="line">}</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"[UDP Client]: Connection or binding succeed\n"</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">ssize_t</span> sendlen;</span><br><span class="line"><span class="keyword">ssize_t</span> recvlen;</span><br><span class="line"><span class="keyword">socklen_t</span> serlen;</span><br><span class="line"><span class="built_in">memset</span>(&amp;sendlen, <span class="number">0</span>, <span class="built_in"><span class="keyword">sizeof</span></span>(<span class="keyword">ssize_t</span>));</span><br><span class="line"><span class="built_in">memset</span>(&amp;recvlen, <span class="number">0</span>, <span class="built_in"><span class="keyword">sizeof</span></span>(<span class="keyword">ssize_t</span>));</span><br><span class="line"><span class="built_in">memset</span>(&amp;serlen, <span class="number">0</span>, <span class="built_in"><span class="keyword">sizeof</span></span>(serlen));</span><br><span class="line">serlen = <span class="built_in"><span class="keyword">sizeof</span></span>(cliaddr);</span><br><span class="line"><span class="built_in">strcpy</span>(sendmsg, <span class="string">"Hello Server,I'm client"</span>);</span><br><span class="line"><span class="keyword">while</span> (<span class="number">1</span>)</span><br><span class="line">{</span><br><span class="line">sendlen = <span class="built_in">sendto</span>(sockfd, sendmsg, <span class="built_in">strlen</span>(sendmsg) + <span class="number">1</span>, <span class="number">0</span>, (struct sockaddr*)&amp;cliaddr, serlen);</span><br><span class="line"><span class="keyword">if</span> (sendlen &gt; <span class="number">0</span>)</span><br><span class="line">{</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"[UDP Client]: Send to server message: (%s)\n"</span>, sendmsg);</span><br><span class="line"><span class="built_in">bzero</span>(recvmsg, UDP_CLIENT_BUFF_SIZE);</span><br><span class="line">recvlen = <span class="built_in">recvfrom</span>(sockfd, recvmsg, UDP_CLIENT_BUFF_SIZE, <span class="number">0</span>, (struct sockaddr*)&amp;cliaddr, &amp;serlen);</span><br><span class="line"><span class="keyword">if</span> (recvlen &gt; <span class="number">0</span>)</span><br><span class="line">{</span><br><span class="line">recvmsg[recvlen] = <span class="string">'\0'</span>;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"[UDP Client]: Recv from server message: (%s)\n"</span>, recvmsg);</span><br><span class="line">}</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">{</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">}</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">{</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">}</span><br><span class="line"><span class="built_in">sleep</span>(<span class="number">1</span>);</span><br><span class="line">}</span><br><span class="line"><span class="built_in">close</span>(sockfd);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"[UDP Client]: Close\n"</span>);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">计算机网络的基础概念、TCP/IP 网络编程</summary>
    
    
    
    <category term="网络技术" scheme="http://example.com/categories/%E7%BD%91%E7%BB%9C%E6%8A%80%E6%9C%AF/"/>
    
    
    <category term="技术博客" scheme="http://example.com/tags/%E6%8A%80%E6%9C%AF%E5%8D%9A%E5%AE%A2/"/>
    
  </entry>
  
  <entry>
    <title>2.1.2 I/O 多路复用</title>
    <link href="http://example.com/2021/12/15/2.1.2.IO%E5%A4%9A%E8%B7%AF%E5%A4%8D%E7%94%A8/"/>
    <id>http://example.com/2021/12/15/2.1.2.IO%E5%A4%9A%E8%B7%AF%E5%A4%8D%E7%94%A8/</id>
    <published>2021-12-14T16:54:08.000Z</published>
    <updated>2021-12-18T04:30:32.018Z</updated>
    
    <content type="html"><![CDATA[<hr><h1 id="2-1-2-I-O-多路复用"><a href="#2-1-2-I-O-多路复用" class="headerlink" title="2.1.2 I/O 多路复用"></a>2.1.2 I/O 多路复用</h1><hr><blockquote><p><strong>重点内容</strong></p><ul><li><strong>网络 I/O 模型、I/O 多路复用</strong></li><li><strong>水平触发和边缘触发</strong></li><li><strong>select() 系统调用</strong></li><li><strong>poll() 系统调用</strong></li><li><strong>epoll() 编程接口</strong></li></ul></blockquote><hr><h2 id="2-1-2-1-网络-I-O-模型与-I-O-多路复用"><a href="#2-1-2-1-网络-I-O-模型与-I-O-多路复用" class="headerlink" title="2.1.2.1 网络 I/O 模型与 I/O 多路复用"></a>2.1.2.1 网络 I/O 模型与 I/O 多路复用</h2><blockquote><p><strong>Unix 有五种 I/O 模型：阻塞 I/O 模型(blocking I/O model)、非阻塞 I/O 模型(non-blocking model)、多路复用 I/O 模型(I/O multiplexing model)、信号驱动式 I/O 模型(signal blocking I/O model)、异步 I/O 模型(asynchronous I/O model)</strong></p></blockquote><ul><li><strong>(1) 阻塞与非阻塞的概念</strong></li></ul><blockquote><ul><li><strong>阻塞：阻塞调用是指调用的 I/O 函数没有完成相关的功能，在调用结果返回之前，当前进程被挂起。函数只有在得到结果之后才会返回<br><br>阻塞型 I/O 模型一般适用于单个设备的操作或者不是特别紧急传输数据时，例如：管道设备、终端设备、单客户端的网络设备，阻塞 I/O 最常用、最简单、效率也最低</strong><br><img src="2.2.0.blocking-IO-model.jpg" alt="阻塞 I/O 模型" title="嘉措一郎(Gyatso Ichiro)"></li></ul></blockquote><blockquote><ul><li><strong>非阻塞：非阻塞调用是指当请求的 I/O 操作不能完成时，即使不能立刻返回调用结果也不会阻塞当前进程，而是立即返回 <br><br>非阻塞 I/O 模型适用于 I/O 多路复用(一个进程处理多路数据)，非阻塞 I/O 防止阻塞在 I/O 上，需要轮询</strong><br><img src="2.2.1.non-blocking-IO-model.jpg" alt="非阻塞 I/O 模型" title="嘉措一郎(Gyatso Ichiro)"></li></ul></blockquote><ul><li><strong>(2) 多路复用 I/O 模型</strong></li></ul><blockquote><p><strong>I/O 多路复用允许同时检查多个文件描述符的一种机制</strong></p></blockquote><blockquote><ul><li><strong>内核添加一张表，监听表里面的信息，当有资源准备就绪，就执行</strong></li><li><strong>资源 –文件描述符去除与否</strong></li><li><strong>创建监听表</strong><br><img src="2.2.2.IO-multiplexing-model.jpg" alt="多路复用 I/O 模型" title="嘉措一郎(Gyatso Ichiro)"></li></ul></blockquote><ul><li><strong>(3) 信号驱动式 I/O 和异步 I/O 模型</strong></li></ul><blockquote><ul><li><strong>在信号驱动 I/O 中，文件描述符上可执行 I/O 操作时，进程请求内核为自己发送一个信号，之后进程就可以执行任何其它的任务直到 I/O 就绪为止，此时内核会发送信号给进程，要使用信号驱动 I/O ，程序需要按照如下步骤执行：</strong><blockquote><ul><li><strong>为内核发送的通知信号安装一个信号处理例程</strong></li><li><strong>设定文件描述符的属主，也就是当文件描述符上可执行 I/O 时，会收到通知信号的进程或进程组，fcntl(fd, F_SETOWN, pid);</strong></li><li><strong>通过设定 O_NONBLOCK 标志使能非阻塞 I/O</strong></li><li><strong>通过打开 O_ASYNC 标志使能信号驱动 I/O</strong></li><li><strong>调用进程可以执行其它的任务了</strong></li><li><strong>信号驱动 I/O 提供的是边缘触发通知</strong></li></ul></blockquote></li></ul></blockquote><blockquote><ul><li><strong>异步 I/O 模型</strong><blockquote><ul><li><strong>数据从磁盘加载到buffer中，再将buffer中的数据复制到用户进程缓存区。当数据复制完成后，内核会发生一个信号给进程，这样进程会在用户进程缓存区中读取数据，而后再返回给客户端。其工做原理如图所示</strong><br><img src="2.2.3.asynchronous-IO-model.jpg" alt="信号驱动式 I/O 模型" title="嘉措一郎(Gyatso Ichiro)"></li></ul></blockquote></li></ul></blockquote><blockquote><blockquote><ul><li><strong>异步 I/O 模型与信号驱动 I/O 模型的主要区别在于；信号驱动模型是由内核告知什么时候启动 I/O 操做；而异步 I/O 模型是由内核告知 I/O 操做什么时候完成</strong></li></ul></blockquote></blockquote><hr><h3 id="2-1-2-2-水平触发和边缘触发"><a href="#2-1-2-2-水平触发和边缘触发" class="headerlink" title="2.1.2.2 水平触发和边缘触发"></a>2.1.2.2 水平触发和边缘触发</h3><blockquote><p><strong>水平触发和边缘触发是文件描述符准备就绪的两种通知模式</strong></p></blockquote><blockquote><ul><li>水平触发通知：如果文件描述符上可以非阻塞地执行 I/O 系统调用，此时认为它已经就绪</li></ul></blockquote><blockquote><ul><li>边缘触发通知：如果文件描述符自上次状态检查以来有了新的 I/O 活动(比如新的输入)，此时需要触发通知</li></ul></blockquote><hr><h3 id="2-1-2-3-select-系统调用"><a href="#2-1-2-3-select-系统调用" class="headerlink" title="2.1.2.3 select()系统调用"></a>2.1.2.3 select()系统调用</h3><ul><li><p><strong>系统调用 selec t会一直阻塞，直到一个或多个文件描述符集合成为就绪态</strong></p></li><li><p><strong>(1) 函数原型</strong></p></li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/select.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">select</span><span class="params">(<span class="keyword">int</span> nfds, fd_set *readfds, fd_set *writefds,</span></span></span><br><span class="line"><span class="params"><span class="function">                    fd_set *exceptfds, struct timeval *timeout)</span></span>;</span><br><span class="line"></span><br></pre></td></tr></table></figure><ul><li><strong>(2) 函数参数</strong><blockquote><ul><li><strong>nfds：文件描述符的范围，即所有文件描述符的最大值加 1，不能出错</strong></li><li><strong>readfds：监听读资源的文件描述符集合</strong></li><li><strong>writefds：监听写资源的文件描述符集合</strong></li><li><strong>exceptfds：监听异常资源的文件描述符集合</strong></li><li><strong>timeout：NULL 一直等待， 或者根据 struct timeval 设置等待时间的上限值</strong> </li></ul></blockquote></li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">timeval</span> {</span></span><br><span class="line">    <span class="keyword">long</span>    tv_sec;         <span class="comment">/* seconds */</span>  <span class="comment">/*  秒  */</span></span><br><span class="line">    <span class="keyword">long</span>    tv_usec;        <span class="comment">/* microseconds */</span>  <span class="comment">/*  微妙  */</span></span><br><span class="line">};</span><br><span class="line"></span><br></pre></td></tr></table></figure><p><strong>readfds、writefds 和 exceptfds 所指向的结构体都是保存结果值的地方，在调用 select() 之前，这些参数指向的结构体必须初始化(通过 FD_ZERO() 和 FD_SET())</strong></p><ul><li><strong>(3) 返回值：成功返回已经准备就绪的文件描述符个数， 失败返回 -1</strong><blockquote><ul><li><strong>返回 -1 表示有错误发生</strong></li><li><strong>返回 0 表示在任何文件描述符成为就绪态之前 select() 调用已经超时</strong></li><li><strong>返回一个正整数表示有一个或多个文件描述符已经处于就绪态</strong></li></ul></blockquote></li></ul><p><strong>通常数据类型 fd_set 以位掩码的形式来实现</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">FD_CLR</span><span class="params">(<span class="keyword">int</span> fd, fd_set *set)</span></span>;    <span class="comment">/*  将文件描述符 fd 从 set 所指向的集合中移除 */</span></span><br><span class="line"><span class="function"><span class="keyword">int</span>  <span class="title">FD_ISSET</span><span class="params">(<span class="keyword">int</span> fd, fd_set *set)</span></span>;  <span class="comment">/*  判断文件描述符 fd 是否在 srt 所指向的集合中  */</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">FD_SET</span><span class="params">(<span class="keyword">int</span> fd, fd_set *set)</span></span>;    <span class="comment">/*  将文件描述 fd 添加到 set 所指向的集合中  */</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">FD_ZERO</span><span class="params">(fd_set *set)</span></span>;           <span class="comment">/*  将 set 所指向的集合初始化为空  */</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><blockquote><p><strong>注意</strong> <br><br><strong>select 正确返回时，会将准备好的文件描述符在集合中对应的位置置 1，其它位置全部置 0，为了保证任然可以监听其它没有 ready 的描述符，必须先将之前的集合保存下来</strong> <br></p></blockquote><ul><li><p><strong>在 Linux 上，异常情况只会在以下两种情况下发生：</strong></p><ul><li><strong>连接到处于信包模式下的伪终端主设备上的从设备状态发生了改变</strong></li><li><strong>流式套接字上接收到了带外数据</strong></li></ul></li><li><p><strong>结构体 fd_set 的大小</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">linux<span class="number">-5.15</span><span class="number">.2</span>\include\linux\types.h</span><br><span class="line"><span class="keyword">typedef</span> __kernel_fd_setfd_set;</span><br><span class="line"></span><br><span class="line">linux<span class="number">-5.15</span><span class="number">.2</span>\include\uapi\linux\posix_types.h</span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> __FD_SETSIZE1024</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> {</span></span><br><span class="line"> <span class="keyword">unsigned</span> <span class="keyword">long</span> fds_bits[__FD_SETSIZE / (<span class="number">8</span> * <span class="built_in"><span class="keyword">sizeof</span></span>(<span class="keyword">long</span>))];</span><br><span class="line">} __kernel_fd_set;</span><br><span class="line"></span><br></pre></td></tr></table></figure></li><li><p><strong>(3) select() 系统调用的基本原理</strong><br><img src="2.2.4.select%E7%9A%84%E5%9F%BA%E6%9C%AC%E5%8E%9F%E7%90%86.jpg" alt="select() 系统调用的基本原理" title="嘉措一郎(Gyatso Ichiro)"></p></li></ul><hr><h3 id="2-1-2-4-poll-系统调用"><a href="#2-1-2-4-poll-系统调用" class="headerlink" title="2.1.2.4 poll()系统调用"></a>2.1.2.4 poll()系统调用</h3><ul><li><p><strong>系统调用 poll() 执行的任务同 select() 相似，主要区别在于如何指定待检查的文件描述符</strong></p></li><li><p><strong>在 select() 中，提供三个集合，在每个集合中标明所需的文件描述符</strong></p></li><li><p><strong>poll() 管理多个文件描述符进行轮询操作(查询文件描述符，如果有指定的事件发生立刻返回)，根据文件描述的状态进行处理，一般通过返回值来确定事件是否发生，没有文件描述符个数的限制</strong></p></li><li><p><strong>poll() 指定时间内轮询指定文件描述符，如果有指定事件发生返回一个真值</strong></p></li><li><p><strong>(1) 函数原型</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;poll.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">poll</span><span class="params">(struct pollfd *fds, <span class="keyword">nfds_t</span> nfds, <span class="keyword">int</span> timeout)</span></span>;</span><br><span class="line"></span><br></pre></td></tr></table></figure></li><li><p><strong>(2) 函数参数</strong></p><blockquote><ul><li><strong>参数 fds 列出了需要 poll() 来检查的文件描述符，该参数为 pollfd 结构体：</strong></li></ul></blockquote><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">pollfd</span> {</span></span><br><span class="line">    <span class="keyword">int</span>   fd;         <span class="comment">/* file descriptor */</span>    <span class="comment">/*  文件描述符  */</span></span><br><span class="line">    <span class="keyword">short</span> events;     <span class="comment">/* requested events */</span>   <span class="comment">/*  请求事件，位掩码  */</span></span><br><span class="line">    <span class="keyword">short</span> revents;    <span class="comment">/* returned events */</span>    <span class="comment">/*  返回事件，位掩码  */</span></span><br><span class="line">};</span><br><span class="line"></span><br></pre></td></tr></table></figure></li></ul><blockquote><ul><li><strong>参数 nfds 指定了结构体 fds 中元素的个数，nfds_t 实际为无符号整型</strong></li></ul></blockquote><blockquote><ul><li><strong>参数 timeout 决定了 poll() 的阻塞行为：</strong><ul><li><strong>如果 timeout 等于 -1，poll() 会一直阻塞直到 fds 中列出的文件描述符有一个达到就绪态(定义在对应的 events 字段中)或者捕获到一个信号</strong></li><li><strong>如果 timeout 等于 0，poll() 不会阻塞，只执行一次检查，查看哪个文件描述符处于就绪态</strong></li><li><strong>如果 timeout 大于 0，poll() 至多阻塞 timeout 毫秒，timeout 的精度受软件时钟粒度的限制</strong></li></ul></li></ul></blockquote><ul><li><strong>(3) 返回值：成功时 poll() 返回结构体中 events 域不为 0 的文件描述符个数，如果在超时前没有任何事件发生，poll() 会返回 0，失败返回 -1</strong></li></ul><blockquote><blockquote><ul><li><strong>注意</strong> <br></li></ul><p><strong>select() 和 poll() 返回正整数时的细小差别，如果一个文件描述符在返回的描述符集合中出现不止一次，系统调用 select() 会将同一个描述符计数多次，而系统调用 poll() 返回的是就绪态的文件描述符个数，且一个文件描述符只会统计一次，就算在相应的 revents 字段中设定了多个位掩码也是如此</strong></p></blockquote></blockquote><p><strong>文件描述符何时就绪</strong></p><ul><li><p><strong>SUSv3中：如果对 I/O 函数的调用不会阻塞，而不论该函数是否能够实际传输数据，此时文件描述符被认为是就绪的</strong></p></li><li><p><strong>(4) 比较 select() 和 poll()</strong></p><ul><li><p><strong>Linux 内核层面：select() 和 poll() 都使用了相同的内核 poll 例程集合，每个历程都返回有关单个文件描述符就绪的信息，就绪信息以掩码的形式返回，如果被检查的文件描述当中有一个关闭了，poll() 会在 revents 字段中返回 POLLNVAL，而 select() 会返回 -1 且将错误码设为 EBADF</strong></p></li><li><p><strong>select() 所使用的数据类型 fd_set 对于被检查的文件描述符数量有上限限制，FD_SETSIZE 默认为1024，poll() 对于被检查的文件描述符数量本质上没有限制</strong></p></li><li><p><strong>由于 select() 的参数 fd_set 同时也是保存调用结果的地方(保存返回值)，如果在循环中重复调用 select() ，必须每次都要重新初始化 fd_set，而 poll() 通过独立的两个字段 events(针对输入)和 revents(针对输出)分别来处理，避免了每次重新初始化参数的操作</strong></p></li><li><p><strong>select() 提供的超时精度(微妙)比 poll() 提供的超时精度(毫秒)高，这两个系统调用的超时精度都受软件时钟粒度的限制</strong></p></li></ul></li><li><p><strong>(5) select() 和 poll() 存在的问题</strong></p><ul><li><p><strong>每次调用 select() 和 poll()，内核必须检查所有被指定的文件描述符是否处于就绪态，当检查大量处于密集范围内的文件描述符时，该操作耗费的时间将大大超过接下来的操作</strong></p></li><li><p><strong>每次调用 select() 和 poll()，程序必须传递一个表示所有需要被检查的文件描述符数据结构到内核中，内核检查过后修改这个数据结构并返回给程序，select() 每次都要初始化这个数据结构，poll() 随着待检查文件描述符的数量增加，从用户空间到内核空间来回拷贝将占用大量 CPU 时间</strong></p></li><li><p><strong>通常程序重复调用这些系统调用所检查的文件描述符集合都是相同的，可内核并不会每次调用之后记录它们</strong></p></li></ul></li></ul><hr><h3 id="2-1-2-5-epoll-编程接口"><a href="#2-1-2-5-epoll-编程接口" class="headerlink" title="2.1.2.5 epoll 编程接口"></a>2.1.2.5 epoll 编程接口</h3><p><strong>同 I/O 多路复用和信号驱动 I/O 一样，linux 的 epoll(event poll) API 可以检查多个文件描述符上的 I/O 就绪状态</strong></p><ul><li><p><strong>(1) epoll API 的优势</strong></p><ul><li><p><strong>当检查大量的文件描述符时，epoll 的性能延展性比 select() 和 poll() 高</strong></p></li><li><p><strong>epoll API 既支持水平触发也支持边缘触发，select() 和 poll() 只支持水平触发，信号驱动 I/O 只支持边缘触发</strong></p></li><li><p><strong>可以避免复杂的信号处理流程，比如信号队列溢出时的处理</strong></p></li><li><p><strong>灵活性高，可以指定我们希望检查的数据类型，例如，检查套接字文件描述符的读就绪、写就绪或者两者同时指定</strong></p></li></ul></li><li><p><strong>(2) epoll API 由3个系统调用组成</strong></p><ul><li><p><strong>系统调用 epoll_create() 创建一个 epoll 实列，返回代表该实例的文件描述符</strong></p></li><li><p><strong>系统调用 epoll_ctl() 操作同 epoll 实列相关的兴趣列表，通过 epoll_ctl() 可以增加新的文件描述符到列表中，也可以将已有的文件描述符从列表中移除，以及修改代表文件描述符上事件类型的位掩码</strong></p></li><li><p><strong>系统调用 epoll_wait() 返回与 epoll 实例相关联的就绪列表中的成员</strong></p></li></ul></li><li><p><strong>(4) 创建 epoll 实例：epoll_create()</strong></p></li></ul><blockquote><ul><li><strong>函数原型</strong> </li></ul></blockquote><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/epoll.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*  epoll_create, epoll_create1 - open an epoll file descriptor  */</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">epoll_create</span><span class="params">(<span class="keyword">int</span> size)</span></span>;  <span class="comment">/*  On success, these system calls return a nonnegative file descriptor.  On error, -1 is returned, and errno is set to indicate the error  */</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*  linux-5.15.2\fs\eventpoll.c  */</span></span><br><span class="line"><span class="built_in">SYSCALL_DEFINE1</span>(epoll_create, <span class="keyword">int</span>, size)</span><br><span class="line">{</span><br><span class="line"> <span class="keyword">if</span> (size &lt;= <span class="number">0</span>)  <span class="comment">/*  epoll_create 的参数 size 只要大于 0 即可，无实际作用  */</span></span><br><span class="line">  <span class="keyword">return</span> -EINVAL;</span><br><span class="line"></span><br><span class="line"> <span class="keyword">return</span> <span class="built_in">do_epoll_create</span>(<span class="number">0</span>);</span><br><span class="line">}</span><br><span class="line"></span><br></pre></td></tr></table></figure><blockquote><ul><li><strong>函数参数</strong><ul><li><strong>参数：size 只需大于 0 即可，从 linux2.6.8 版本开始忽略不用</strong></li></ul></li></ul></blockquote><blockquote><ul><li><strong>返回值：返回代表新创建 epoll 实例的文件描述符，这个文件描述在其它几个 epoll 系统调用中表示 epoll 实例，当这个文件描述符不再需要时，通过 close() 关闭</strong></li></ul></blockquote><ul><li><p><strong>自 linux2.6.27 版内核开始， 支持一个新的系统调用 epoll_create1()，功能与 epoll_create 相同，去掉了无用参数 size，增加了可以修改系统调用行为的 flag 参数，目前 只支持一个 flag 标志：EPOLL_CLOEXEC</strong></p></li><li><p><strong>(5) 修改 epoll 的兴趣列表：epoll_ctl()</strong></p></li></ul><blockquote><ul><li><strong>系统调用 epoll_ctl() 能够修改由文件描述符 epfd 所代表的 epoll 实例中的兴趣列表</strong></li></ul></blockquote><blockquote><ul><li><strong>函数原型</strong></li></ul></blockquote><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/epoll.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*  epoll_ctl - control interface for an epoll descriptor  */</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">epoll_ctl</span><span class="params">(<span class="keyword">int</span> epfd, <span class="keyword">int</span> op, <span class="keyword">int</span> fd, struct epoll_event *event)</span></span>;  <span class="comment">/*  When successful, epoll_ctl() returns zero.  When an error occurs, epoll_ctl() returns -1 and errno is set appropriately  */</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*  结构体 epoll_event 中的 data 字段的类型  */</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">union</span> <span class="title">epoll_data</span> {</span></span><br><span class="line">    <span class="keyword">void</span>        *ptr;</span><br><span class="line">    <span class="keyword">int</span>          fd;</span><br><span class="line">    <span class="keyword">uint32_t</span>     u32;</span><br><span class="line">    <span class="keyword">uint64_t</span>     u64;</span><br><span class="line">} <span class="keyword">epoll_data_t</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*  参数 event 指向的结构体  */</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">epoll_event</span> {</span></span><br><span class="line">    <span class="keyword">uint32_t</span>     events;      <span class="comment">/* Epoll events */</span></span><br><span class="line">    <span class="keyword">epoll_data_t</span> data;        <span class="comment">/* User data variable */</span></span><br><span class="line">};</span><br><span class="line"></span><br></pre></td></tr></table></figure><blockquote><ul><li><strong>函数参数</strong><ul><li><strong>参数 epfd 文件描述符</strong></li><li><strong>参数 fd 指明了要修改兴趣列表中的哪一个文件描述符的设定</strong></li><li><strong>参数 op 指定需要执行的操作，有以下几种值</strong><blockquote><ul><li><strong>EPOLL_CTL_ADD：将描述符 fd 添加到 epoll 实例 epfd 中的兴趣列表中去</strong></li><li><strong>EPOLL_CTL_MOD：修改描述符 fd 上设定的事件，需要用到由 ev 所指向的结构体中的信息</strong></li><li><strong>EPOLL_CTL_DEL：将文件描述符 fd 从 epfd 的兴趣列表中移除</strong></li></ul></blockquote></li><li><strong>参数 event 是指向结构体 epoll_event 的指针，结构体 epoll_event 中的 data 字段类型为 epoll_data</strong> </li><li><strong>参数 event 为文件描述符 fd 所做的设置如下：</strong></li></ul></li></ul></blockquote><ul><li><p><strong>结构体 epoll_event 中的 events 字段是一个位掩码，它指定了待检查的描述符 fd 上所感兴趣的事件集合</strong></p></li><li><p><strong>data 字段是一个共用体，当描述符 fd 稍后成为就绪态时，共用体的成员用来指定传回给调用进程的信息</strong></p></li></ul><blockquote><ul><li><strong>max_user_watches 上限</strong> <br></li></ul><p><strong>每个注册到 epoll 实例上的文件描述符需要占用一小段不能被交换的内核空间，max_user_watches 可以查看和修改可以注册到 epoll 实例上的文件描述符总数，默认的上限值根据系统可用内存大小计算得出</strong></p></blockquote><ul><li><strong>(6) 事件等待：epoll_wait()</strong></li></ul><blockquote><ul><li><strong>系统调用 epoll_wait() 返回 epoll 实例中处于就绪态的文件描述符信息，单个 epoll_wait() 调用能返回多个就绪态文件描述符的信息</strong></li></ul></blockquote><blockquote><ul><li><strong>函数原型</strong></li></ul></blockquote><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">NAME</span><br><span class="line">       epoll_wait, epoll_pwait - wait <span class="keyword">for</span> an I/O event on an epoll file descriptor</span><br><span class="line"></span><br><span class="line">SYNOPSIS</span><br><span class="line">       <span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/epoll.h&gt;</span></span></span><br><span class="line"></span><br><span class="line">       <span class="function"><span class="keyword">int</span> <span class="title">epoll_wait</span><span class="params">(<span class="keyword">int</span> epfd, struct epoll_event *events,</span></span></span><br><span class="line"><span class="params"><span class="function">                            <span class="keyword">int</span> maxevents, <span class="keyword">int</span> timeout)</span></span>;</span><br><span class="line"></span><br></pre></td></tr></table></figure><blockquote><ul><li><strong>函数参数</strong><ul><li><strong>参数 epfd 代表 epoll 实例中兴趣列表的的文件描述符</strong></li><li><strong>参数 events 所指向的结构体数组中返回的是有关就绪态文件描述符的信息，数组 events 的空间由调用者指定，所包含的元素个数在 maxevents 中指定</strong> <br></li></ul></li></ul><p><strong>在数组 events 中，每个元素返回的都是单个就绪态文件描述符的信息，events 字段返回了在该描述符上已经发生的事件掩码，data 字段返回的是在描述符上使用 epoll_ctl() 注册感兴趣的事件时在 ev.data 中所指定的值，注意：data 字段是唯一可获知同这个事件相关的文件描述符号的途径</strong></p><ul><li><strong>参数 timeout 用来确定 epoll_wait() 的阻塞行为，有以下几种</strong> <br></li></ul><p><strong>如果 timeout 等于 -1，将一直阻塞，直到兴趣列表中的文件描述符上有事件产生，或直到捕获到一个信号为止</strong> <br><br><strong>如果 timeout 等于 0，执行一次非阻塞式的检查，看兴趣列表中的文件描述符上产生了哪个事件</strong> <br><br><strong>如果 timeout 大于 0，调用将阻塞至多 timeout 毫秒，直到文件描述符上有事件发生，或者直到捕获到一个信号为止</strong> <br></p></blockquote><blockquote><ul><li><strong>返回值，调用成功后 epoll_wait() 返回数组 events 中的元素个数，如果在 timeout 超时间隔内没有任何文件描述符处于就绪态，返回 0，出错返回 -1</strong></li></ul></blockquote><ul><li><p><strong>在多线程中，可以在一个线程中使用  epoll_ctl() 将文件描述添加到另一个线程中由 epoll_wait() 所监视的 epoll 实例的兴趣列表中，这些对兴趣列表的修改将立刻得到处理，而 epoll_wait() 调用将返回有关新添加的文件描述符的就绪信息</strong></p></li><li><p><strong>(7) epoll 事件</strong></p></li></ul><blockquote><ul><li><strong>当调用 epoll_ctl() 时在 ev.events 中指定的位掩码以及由 epoll_wait() 返回的 events[].event 中的值</strong></li></ul></blockquote><blockquote><ul><li><strong>epoll 中 events 字段上的位掩码值</strong> <br><ul><li><strong>EPOLLIN 作为 epoll_ctl() 的输入，由 epoll_wait() 返回，可读取非高优先级的数据</strong></li><li><strong>EPOLLPRI 作为 epoll_ctl() 的输入，由 epoll_wait() 返回，可读取高优先级的数据</strong></li><li><strong>EPOLLOUT 作为 epoll_ctl() 的输入，由 epoll_wait() 返回，普通数据可写</strong></li><li><strong>EPOLLET 作为 epoll_ctl() 的输入，采用边缘事件触发通知</strong></li></ul></li></ul></blockquote><ul><li><strong>(8) epoll 水平触发通知和边缘触发通知</strong></li></ul><blockquote><ul><li><strong>epoll 默认提供水平触发，epoll 会通知程序何时能再文件描述夫上以以非阻塞方式执行 I/O，同 select 和 poll 提供的通知类型相似</strong></li></ul></blockquote><blockquote><ul><li><strong>epoll 边缘触发，程序调用 epoll_ctl() 时在 ev.events 字段中指定 EPOLLET 标志，epoll 会通知程序自从上一次调用 epoll_wait() 以来文件描述符上是否已经有 I/O 活动了</strong></li></ul></blockquote><blockquote><ul><li><strong>采用边缘触发通知机制的程序基本框架</strong> <br></li></ul><p><strong>1.让所有待监视的文件描述符都成为非阻塞的</strong> <br><br><strong>2.通过 epoll_ctl() 构建 epoll 的兴趣列表</strong> <br><br><strong>3.通过如下的循环处理 I/O 事件</strong> <br></p><blockquote><p><strong>(a)通过 epoll_wait() 取得处于就绪态的文件描述符列表</strong> <br><br><strong>(b)针对每一个处于就绪态的文件描述符，不断进行 I/O 处理直到相关的系统调用(如：read()、write()、recv()、send() 或 accept())返回 EAGAIN 或 EWOULDBLOCK 错误</strong></p></blockquote></blockquote><ul><li><strong>(9) epoll 的基本原理</strong><br><img src="2.2.5.epoll%E5%9F%BA%E6%9C%AC%E5%8E%9F%E7%90%86.jpg" alt="epoll 的基本原理" title="嘉措一郎(Gyatso Ichiro)"></li></ul><hr><h3 id="2-2-6-实例程序"><a href="#2-2-6-实例程序" class="headerlink" title="2.2.6 实例程序"></a>2.2.6 实例程序</h3><ul><li><p><strong><a href="https://gitee.com/geekdeveloper/gyatso-ichiro/blob/master/Linux-C%E5%92%8CC++%E5%90%8E%E7%AB%AF%E6%9C%8D%E5%8A%A1%E5%99%A8%E6%9E%B6%E6%9E%84%E5%BC%80%E5%8F%91/%E7%AC%AC2%E7%AB%A0-%E9%AB%98%E6%80%A7%E8%83%BD%E7%BD%91%E7%BB%9C%E8%AE%BE%E8%AE%A1/2.1.%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/tcp_server_thread.c" title="TCP Server 一请求一线程模型">TCP Server 一请求一线程模型</a></strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">thread_arg</span></span></span><br><span class="line"><span class="class">{</span></span><br><span class="line"><span class="keyword">int</span> clifd;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in</span> <span class="title">cliaddr</span>;</span></span><br><span class="line">};</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span>* <span class="title">start_routine</span><span class="params">(<span class="keyword">void</span>* arg)</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line"><span class="keyword">char</span> recvmsg[TCP_SERVER_BUFF_SIZE] = { <span class="string">'\0'</span> };  <span class="comment">/*  服务器端接收数据缓冲区  */</span></span><br><span class="line"><span class="keyword">char</span> sendmsg[TCP_SERVER_BUFF_SIZE] = { <span class="string">'\0'</span> };  <span class="comment">/*  服务器端发送数据缓冲区  */</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">thread_arg</span> *<span class="title">sarg</span>=</span> (struct thread_arg*)arg;</span><br><span class="line"></span><br><span class="line"><span class="keyword">ssize_t</span> reclen;</span><br><span class="line"><span class="built_in">memset</span>(&amp;reclen, <span class="number">0</span>, <span class="built_in"><span class="keyword">sizeof</span></span>(reclen));</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span> (<span class="number">1</span>)</span><br><span class="line">{</span><br><span class="line"><span class="built_in">bzero</span>(recvmsg, TCP_SERVER_BUFF_SIZE);</span><br><span class="line">reclen = <span class="built_in">recv</span>(sarg-&gt;clifd, recvmsg, TCP_SERVER_BUFF_SIZE, <span class="number">0</span>);</span><br><span class="line"><span class="keyword">if</span> (reclen &gt; <span class="number">0</span>)</span><br><span class="line">{</span><br><span class="line">recvmsg[reclen] = <span class="string">'\0'</span>;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"[TCP Server]: From %s client message: (%s)\n"</span>, <span class="built_in">inet_ntoa</span>(sarg-&gt;cliaddr.sin_addr), recvmsg);</span><br><span class="line"></span><br><span class="line"><span class="built_in">strcpy</span>(sendmsg, recvmsg);</span><br><span class="line"><span class="built_in">send</span>(sarg-&gt;clifd, sendmsg, <span class="built_in">strlen</span>(sendmsg) + <span class="number">1</span>, <span class="number">0</span>);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"[TCP Server]: To client send message: (%s)\n"</span>, <span class="built_in">inet_ntoa</span>(sarg-&gt;cliaddr.sin_addr));</span><br><span class="line">}</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">{</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">}</span><br><span class="line">}</span><br><span class="line"><span class="built_in">close</span>(sarg-&gt;clifd);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"TCP Server close\n"</span>);</span><br><span class="line"><span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">/*  一请求一线程  */</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">tcp_server_thread</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line"><span class="comment">/*  创建套接字 sockfd  */</span></span><br><span class="line"><span class="keyword">int</span> sockfd = <span class="built_in">socket</span>(AF_INET, SOCK_STREAM, <span class="number">0</span>);</span><br><span class="line"><span class="keyword">if</span> (<span class="number">-1</span> == sockfd)</span><br><span class="line">{</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"[TCP Server]: Create a socket file descriptor error\n"</span>);</span><br><span class="line"><span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">}</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"[TCP Server]: Create a socket file descriptor succeed\n"</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">/*  填充数据结构体  struct sockaddr_in  */</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in</span> <span class="title">seraddr</span>;</span></span><br><span class="line"><span class="built_in">memset</span>(&amp;seraddr, <span class="number">0</span>, <span class="built_in"><span class="keyword">sizeof</span></span>(seraddr));</span><br><span class="line">seraddr.sin_family = AF_INET;                   <span class="comment">/*  地址族：IPv4  */</span></span><br><span class="line">seraddr.sin_port = <span class="built_in">htons</span>(TCP_SERVER_PORT);      <span class="comment">/*  端口号  */</span></span><br><span class="line">seraddr.sin_addr.s_addr = <span class="built_in">htonl</span>(TCP_SERVER_IP); <span class="comment">/*  IP地址  */</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*  绑定端口号和IP地址到套接字 sockfd  */</span></span><br><span class="line"><span class="keyword">if</span> (<span class="number">-1</span> == <span class="built_in">bind</span>(sockfd, (struct sockaddr*)&amp;seraddr, <span class="built_in"><span class="keyword">sizeof</span></span>(seraddr)))</span><br><span class="line">{</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"[TCP Server]: Bind a server IP addr  and port to sockfd error\n"</span>);</span><br><span class="line"><span class="keyword">return</span> <span class="number">-2</span>;</span><br><span class="line">}</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"[TCP Server]: Bind a server IP addr  and port to sockfd succeed\n"</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">/*  开始监听，设置最大链接数  */</span></span><br><span class="line"><span class="keyword">if</span> (<span class="number">-1</span> == <span class="built_in">listen</span>(sockfd, TCP_SERVER_BACKLOG))</span><br><span class="line">{</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"[TCP Server]: Listen for connections on a sockfd error\n"</span>);</span><br><span class="line"><span class="keyword">return</span> <span class="number">-3</span>;</span><br><span class="line">}</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"[TCP Server]: Listen for connections on a sockfd succeed\n"</span>);</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in</span> <span class="title">cliaddr</span>;</span></span><br><span class="line"><span class="built_in">memset</span>(&amp;cliaddr, <span class="number">0</span>, <span class="built_in"><span class="keyword">sizeof</span></span>(cliaddr));</span><br><span class="line"><span class="keyword">socklen_t</span> cliaddrlen = <span class="built_in"><span class="keyword">sizeof</span></span>(cliaddr);</span><br><span class="line"><span class="keyword">int</span> clifd = <span class="number">0</span>;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">thread_arg</span> <span class="title">arg</span>;</span></span><br><span class="line"><span class="keyword">pthread_t</span> thread = { <span class="number">0</span> };</span><br><span class="line"></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"[TCP Server]: Waiting for client's link request\n"</span>);</span><br><span class="line"><span class="keyword">while</span> (<span class="number">1</span>)</span><br><span class="line">{</span><br><span class="line"><span class="comment">/*  等待来自客户端的连接请求  */</span></span><br><span class="line"><span class="built_in">memset</span>(&amp;cliaddr, <span class="number">0</span>, <span class="built_in"><span class="keyword">sizeof</span></span>(cliaddr));</span><br><span class="line">cliaddrlen = <span class="built_in"><span class="keyword">sizeof</span></span>(cliaddr);</span><br><span class="line">clifd = <span class="built_in">accept</span>(sockfd, (struct sockaddr*)&amp;cliaddr, &amp;cliaddrlen);</span><br><span class="line"><span class="keyword">if</span> (<span class="number">-1</span> == clifd)</span><br><span class="line">{</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"[TCP Server]: Accept a connection on a clifd error\n"</span>);</span><br><span class="line"><span class="keyword">return</span> <span class="number">-4</span>;</span><br><span class="line">}</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"[TCP Server]: Accept a connection on a clifd succeed\n"</span>);</span><br><span class="line"></span><br><span class="line"><span class="built_in">memset</span>(&amp;arg, <span class="number">0</span>, <span class="built_in"><span class="keyword">sizeof</span></span>(arg));</span><br><span class="line">arg.clifd = clifd;</span><br><span class="line">arg.cliaddr.sin_addr = cliaddr.sin_addr;</span><br><span class="line"><span class="built_in">pthread_create</span>(&amp;thread, <span class="literal">NULL</span>, start_routine, (<span class="keyword">void</span>*)&amp;arg);</span><br><span class="line">}</span><br><span class="line"><span class="built_in">close</span>(sockfd);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"[TCP Server]: Close\n"</span>);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br><span class="line"></span><br></pre></td></tr></table></figure></li><li><p><strong><a href="https://gitee.com/geekdeveloper/gyatso-ichiro/blob/master/Linux-C%E5%92%8CC++%E5%90%8E%E7%AB%AF%E6%9C%8D%E5%8A%A1%E5%99%A8%E6%9E%B6%E6%9E%84%E5%BC%80%E5%8F%91/%E7%AC%AC2%E7%AB%A0-%E9%AB%98%E6%80%A7%E8%83%BD%E7%BD%91%E7%BB%9C%E8%AE%BE%E8%AE%A1/2.1.%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/tcp_server_select.c" title="TCP Server select() 模型">TCP Server select() 模型</a></strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">/*  TCP Server I/O 多路复用 select  */</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">tcp_server_select</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line"><span class="keyword">char</span> recvmsg[TCP_SERVER_BUFF_SIZE] = { <span class="string">'\0'</span> };  <span class="comment">/*  服务器端接收数据缓冲区  */</span></span><br><span class="line"><span class="keyword">char</span> sendmsg[TCP_SERVER_BUFF_SIZE] = { <span class="string">'\0'</span> };  <span class="comment">/*  服务器端发送数据缓冲区  */</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*  创建套接字 sockfd  */</span></span><br><span class="line"><span class="keyword">int</span> sockfd = <span class="built_in">socket</span>(AF_INET, SOCK_STREAM, <span class="number">0</span>);</span><br><span class="line"><span class="keyword">if</span> (<span class="number">-1</span> == sockfd)</span><br><span class="line">{</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"[TCP Server]: Create a socket file descriptor error\n"</span>);</span><br><span class="line"><span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">}</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"[TCP Server]: Create a socket file descriptor succeed\n"</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">/*  填充数据结构体  struct sockaddr_in  */</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in</span> <span class="title">seraddr</span>;</span></span><br><span class="line"><span class="built_in">memset</span>(&amp;seraddr, <span class="number">0</span>, <span class="built_in"><span class="keyword">sizeof</span></span>(seraddr));</span><br><span class="line">seraddr.sin_family = AF_INET;                   <span class="comment">/*  地址族：IPv4  */</span></span><br><span class="line">seraddr.sin_port = <span class="built_in">htons</span>(TCP_SERVER_PORT);      <span class="comment">/*  端口号  */</span></span><br><span class="line">seraddr.sin_addr.s_addr = <span class="built_in">htonl</span>(TCP_SERVER_IP); <span class="comment">/*  IP地址  */</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*  绑定端口号和IP地址到套接字 sockfd  */</span></span><br><span class="line"><span class="keyword">if</span> (<span class="number">-1</span> == <span class="built_in">bind</span>(sockfd, (struct sockaddr*)&amp;seraddr, <span class="built_in"><span class="keyword">sizeof</span></span>(seraddr)))</span><br><span class="line">{</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"[TCP Server]: Bind a server IP addr  and port to sockfd error\n"</span>);</span><br><span class="line"><span class="keyword">return</span> <span class="number">-2</span>;</span><br><span class="line">}</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"[TCP Server]: Bind a server IP addr  and port to sockfd succeed\n"</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">/*  开始监听，设置最大链接数  */</span></span><br><span class="line"><span class="keyword">if</span> (<span class="number">-1</span> == <span class="built_in">listen</span>(sockfd, TCP_SERVER_BACKLOG))</span><br><span class="line">{</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"[TCP Server]: Listen for connections on a sockfd error\n"</span>);</span><br><span class="line"><span class="keyword">return</span> <span class="number">-3</span>;</span><br><span class="line">}</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"[TCP Server]: Listen for connections on a sockfd succeed\n"</span>);</span><br><span class="line"></span><br><span class="line">fd_set rfds = { <span class="number">0</span> };</span><br><span class="line">fd_set rset = { <span class="number">0</span> };</span><br><span class="line">fd_set wfds = { <span class="number">0</span> };</span><br><span class="line">fd_set wset = { <span class="number">0</span> };</span><br><span class="line"><span class="built_in">FD_ZERO</span>(&amp;rfds);</span><br><span class="line"><span class="built_in">FD_ZERO</span>(&amp;wfds);</span><br><span class="line"><span class="built_in">FD_SET</span>(sockfd, &amp;rfds);</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> maxfds = sockfd;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in</span> <span class="title">cliaddr</span>;</span></span><br><span class="line"><span class="built_in">memset</span>(&amp;cliaddr, <span class="number">0</span>, <span class="built_in"><span class="keyword">sizeof</span></span>(cliaddr));</span><br><span class="line"><span class="keyword">socklen_t</span> cliaddrlen = <span class="built_in"><span class="keyword">sizeof</span></span>(cliaddr);</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> nready = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">int</span> clifd = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">ssize_t</span> reclen;</span><br><span class="line"><span class="built_in">memset</span>(&amp;reclen, <span class="number">0</span>, <span class="built_in"><span class="keyword">sizeof</span></span>(reclen));</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"[TCP Server]: Waiting for client's link request\n"</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span> (<span class="number">1</span>)</span><br><span class="line">{</span><br><span class="line">rset = rfds;</span><br><span class="line">wset = wfds;</span><br><span class="line"><span class="comment">/*  等待来自客户端的连接请求  */</span></span><br><span class="line">nready = <span class="built_in">select</span>(maxfds + <span class="number">1</span>, &amp;rset, &amp;wset, <span class="literal">NULL</span>, <span class="literal">NULL</span>);</span><br><span class="line"><span class="keyword">if</span> (<span class="built_in">FD_ISSET</span>(sockfd, &amp;rset))</span><br><span class="line">{</span><br><span class="line"><span class="built_in">memset</span>(&amp;cliaddr, <span class="number">0</span>, <span class="built_in"><span class="keyword">sizeof</span></span>(cliaddr));</span><br><span class="line">cliaddrlen = <span class="built_in"><span class="keyword">sizeof</span></span>(cliaddr);</span><br><span class="line">clifd = <span class="built_in">accept</span>(sockfd, (struct sockaddr*)&amp;cliaddr, &amp;cliaddrlen);</span><br><span class="line"><span class="keyword">if</span> (<span class="number">-1</span> == clifd)</span><br><span class="line">{</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"[TCP Server]: Accept a connection on a clifd error\n"</span>);</span><br><span class="line"><span class="keyword">return</span> <span class="number">-4</span>;</span><br><span class="line">}</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"[TCP Server]: Accept a connection on a clifd succeed\n"</span>);</span><br><span class="line"></span><br><span class="line"><span class="built_in">FD_SET</span>(clifd, &amp;rfds);</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (clifd &gt; maxfds)</span><br><span class="line">{</span><br><span class="line">maxfds = clifd;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (<span class="number">0</span> == --nready)</span><br><span class="line">{</span><br><span class="line"><span class="keyword">continue</span>;</span><br><span class="line">}</span><br><span class="line">}</span><br><span class="line"><span class="keyword">for</span> (i = sockfd + <span class="number">1</span>; i &lt;= maxfds; i++)</span><br><span class="line">{</span><br><span class="line"><span class="keyword">if</span> (<span class="built_in">FD_ISSET</span>(i, &amp;rset))</span><br><span class="line">{</span><br><span class="line"><span class="built_in">bzero</span>(recvmsg, TCP_SERVER_BUFF_SIZE);</span><br><span class="line">reclen = <span class="built_in">recv</span>(i, recvmsg, TCP_SERVER_BUFF_SIZE, <span class="number">0</span>);</span><br><span class="line"><span class="keyword">if</span> (reclen &gt; <span class="number">0</span>)</span><br><span class="line">{</span><br><span class="line">recvmsg[reclen] = <span class="string">'\0'</span>;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"[TCP Server]: From %s client message: (%s)\n"</span>, <span class="built_in">inet_ntoa</span>(cliaddr.sin_addr), recvmsg);</span><br><span class="line"></span><br><span class="line"><span class="built_in">FD_CLR</span>(i, &amp;rfds);</span><br><span class="line"><span class="built_in">FD_SET</span>(i, &amp;wfds);</span><br><span class="line">}</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (<span class="number">0</span> == reclen)</span><br><span class="line">{</span><br><span class="line"><span class="built_in">FD_CLR</span>(i, &amp;rfds);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"disconnect\n"</span>);</span><br><span class="line"><span class="built_in">close</span>(i);</span><br><span class="line">}</span><br><span class="line"><span class="keyword">if</span> (<span class="number">0</span> == --nready)</span><br><span class="line">{</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">}</span><br><span class="line">}</span><br><span class="line"><span class="keyword">if</span> (<span class="built_in">FD_ISSET</span>(i, &amp;wset))</span><br><span class="line">{</span><br><span class="line"><span class="built_in">bzero</span>(sendmsg, TCP_SERVER_BUFF_SIZE);</span><br><span class="line"><span class="built_in">strcpy</span>(sendmsg, recvmsg);</span><br><span class="line"></span><br><span class="line"><span class="built_in">send</span>(i, sendmsg, <span class="built_in">strlen</span>(sendmsg) + <span class="number">1</span>, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line"><span class="built_in">FD_CLR</span>(i, &amp;wfds);    <span class="comment">/*  清除写事件标志  */</span></span><br><span class="line"><span class="built_in">FD_SET</span>(i, &amp;rfds);    <span class="comment">/*  修改为读事件  */</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"[TCP Server]: To client send message: (%s)\n"</span>, <span class="built_in">inet_ntoa</span>(cliaddr.sin_addr));</span><br><span class="line"><span class="keyword">if</span> (<span class="number">0</span> == <span class="built_in">strncmp</span>(<span class="string">"exit"</span>, recvmsg, <span class="number">4</span>))</span><br><span class="line">{</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">}</span><br><span class="line">}</span><br><span class="line">}</span><br><span class="line">}</span><br><span class="line"><span class="built_in">close</span>(sockfd);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"[TCP Server]: Close\n"</span>);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br><span class="line"></span><br></pre></td></tr></table></figure></li><li><p><strong><a href="https://gitee.com/geekdeveloper/gyatso-ichiro/blob/master/Linux-C%E5%92%8CC++%E5%90%8E%E7%AB%AF%E6%9C%8D%E5%8A%A1%E5%99%A8%E6%9E%B6%E6%9E%84%E5%BC%80%E5%8F%91/%E7%AC%AC2%E7%AB%A0-%E9%AB%98%E6%80%A7%E8%83%BD%E7%BD%91%E7%BB%9C%E8%AE%BE%E8%AE%A1/2.1.%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/tcp_server_poll.c" title="TCP Server poll() 模型">TCP Server poll() 模型</a></strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">/*  TCP Server poll  */</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">tcp_server_poll</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line"><span class="keyword">char</span> recvmsg[TCP_SERVER_BUFF_SIZE] = { <span class="string">'\0'</span> };  <span class="comment">/*  服务器端接收数据缓冲区  */</span></span><br><span class="line"><span class="keyword">char</span> sendmsg[TCP_SERVER_BUFF_SIZE] = { <span class="string">'\0'</span> };  <span class="comment">/*  服务器端发送数据缓冲区  */</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*  创建套接字 sockfd  */</span></span><br><span class="line"><span class="keyword">int</span> sockfd = <span class="built_in">socket</span>(AF_INET, SOCK_STREAM, <span class="number">0</span>);</span><br><span class="line"><span class="keyword">if</span> (<span class="number">-1</span> == sockfd)</span><br><span class="line">{</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"[TCP Server]: Create a socket file descriptor error\n"</span>);</span><br><span class="line"><span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">}</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"[TCP Server]: Create a socket file descriptor succeed\n"</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">/*  填充数据结构体  struct sockaddr_in  */</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in</span> <span class="title">seraddr</span>;</span></span><br><span class="line"><span class="built_in">memset</span>(&amp;seraddr, <span class="number">0</span>, <span class="built_in"><span class="keyword">sizeof</span></span>(seraddr));</span><br><span class="line">seraddr.sin_family = AF_INET;                   <span class="comment">/*  地址族：IPv4  */</span></span><br><span class="line">seraddr.sin_port = <span class="built_in">htons</span>(TCP_SERVER_PORT);      <span class="comment">/*  端口号  */</span></span><br><span class="line">seraddr.sin_addr.s_addr = <span class="built_in">htonl</span>(TCP_SERVER_IP); <span class="comment">/*  IP地址  */</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*  绑定端口号和IP地址到套接字 sockfd  */</span></span><br><span class="line"><span class="keyword">if</span> (<span class="number">-1</span> == <span class="built_in">bind</span>(sockfd, (struct sockaddr*)&amp;seraddr, <span class="built_in"><span class="keyword">sizeof</span></span>(seraddr)))</span><br><span class="line">{</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"[TCP Server]: Bind a server IP addr  and port to sockfd error\n"</span>);</span><br><span class="line"><span class="keyword">return</span> <span class="number">-2</span>;</span><br><span class="line">}</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"[TCP Server]: Bind a server IP addr  and port to sockfd succeed\n"</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">/*  开始监听，设置最大链接数  */</span></span><br><span class="line"><span class="keyword">if</span> (<span class="number">-1</span> == <span class="built_in">listen</span>(sockfd, TCP_SERVER_BACKLOG))</span><br><span class="line">{</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"[TCP Server]: Listen for connections on a sockfd error\n"</span>);</span><br><span class="line"><span class="keyword">return</span> <span class="number">-3</span>;</span><br><span class="line">}</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"[TCP Server]: Listen for connections on a sockfd succeed\n"</span>);</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">pollfd</span> <span class="title">fds</span>[<span class="title">POLLFD_SIZE</span>] =</span> { <span class="number">0</span> };</span><br><span class="line">fds[<span class="number">0</span>].fd = sockfd;</span><br><span class="line">fds[<span class="number">0</span>].events = POLLIN;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> maxfds = sockfd;</span><br><span class="line"><span class="keyword">int</span> nready = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">int</span> clifd = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in</span> <span class="title">cliaddr</span>;</span></span><br><span class="line"><span class="built_in">memset</span>(&amp;cliaddr, <span class="number">0</span>, <span class="built_in"><span class="keyword">sizeof</span></span>(cliaddr));</span><br><span class="line"><span class="keyword">socklen_t</span> cliaddrlen = <span class="built_in"><span class="keyword">sizeof</span></span>(cliaddr);</span><br><span class="line"><span class="keyword">ssize_t</span> reclen;</span><br><span class="line"><span class="built_in">memset</span>(&amp;reclen, <span class="number">0</span>, <span class="built_in"><span class="keyword">sizeof</span></span>(reclen));</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"[TCP Server]: Waiting for client's link request\n"</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span> (<span class="number">1</span>)</span><br><span class="line">{</span><br><span class="line">nready = <span class="built_in">poll</span>(fds, maxfds + <span class="number">1</span>, <span class="number">-1</span>);</span><br><span class="line"><span class="keyword">if</span> (fds[<span class="number">0</span>].revents &amp; POLLIN)</span><br><span class="line">{</span><br><span class="line"><span class="comment">/*  等待来自客户端的连接请求  */</span></span><br><span class="line"><span class="built_in">memset</span>(&amp;cliaddr, <span class="number">0</span>, <span class="built_in"><span class="keyword">sizeof</span></span>(cliaddr));</span><br><span class="line">cliaddrlen = <span class="built_in"><span class="keyword">sizeof</span></span>(cliaddr);</span><br><span class="line">clifd = <span class="built_in">accept</span>(sockfd, (struct sockaddr*)&amp;cliaddr, &amp;cliaddrlen);</span><br><span class="line"><span class="keyword">if</span> (<span class="number">-1</span> == clifd)</span><br><span class="line">{</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"[TCP Server]: Accept a connection on a clifd error\n"</span>);</span><br><span class="line"><span class="keyword">return</span> <span class="number">-4</span>;</span><br><span class="line">}</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"[TCP Server]: Accept a connection on a clifd succeed\n"</span>);</span><br><span class="line"></span><br><span class="line">fds[clifd].fd = clifd;</span><br><span class="line">fds[clifd].events = POLLIN;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (clifd &gt; maxfds)</span><br><span class="line">{</span><br><span class="line">maxfds = clifd;</span><br><span class="line">}</span><br><span class="line"><span class="keyword">if</span> (<span class="number">0</span> == --nready)</span><br><span class="line">{</span><br><span class="line"><span class="keyword">continue</span>;</span><br><span class="line"></span><br><span class="line">}</span><br><span class="line">}</span><br><span class="line"><span class="keyword">for</span> (i = sockfd + <span class="number">1</span>; i &lt;= maxfds; i++)</span><br><span class="line">{</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (fds[i].revents &amp; POLLIN)</span><br><span class="line">{</span><br><span class="line"><span class="built_in">bzero</span>(recvmsg, TCP_SERVER_BUFF_SIZE);</span><br><span class="line">reclen = <span class="built_in">recv</span>(i, recvmsg, TCP_SERVER_BUFF_SIZE, <span class="number">0</span>);</span><br><span class="line"><span class="keyword">if</span> (reclen &gt; <span class="number">0</span>)</span><br><span class="line">{</span><br><span class="line">recvmsg[reclen] = <span class="string">'\0'</span>;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"[TCP Server]: From %s client message: (%s)\n"</span>, <span class="built_in">inet_ntoa</span>(cliaddr.sin_addr), recvmsg);</span><br><span class="line"></span><br><span class="line"><span class="built_in">strcpy</span>(sendmsg, recvmsg);</span><br><span class="line"><span class="built_in">send</span>(i, sendmsg, <span class="built_in">strlen</span>(sendmsg) + <span class="number">1</span>, <span class="number">0</span>);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"[TCP Server]: To client send message: (%s)\n"</span>, <span class="built_in">inet_ntoa</span>(cliaddr.sin_addr));</span><br><span class="line">}</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (<span class="number">0</span> == reclen)</span><br><span class="line">{</span><br><span class="line"></span><br><span class="line">fds[i].fd = <span class="number">-1</span>;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"disconnect\n"</span>);</span><br><span class="line"><span class="built_in">close</span>(i);</span><br><span class="line"></span><br><span class="line">}</span><br><span class="line"><span class="keyword">if</span> (<span class="number">0</span> == --nready)</span><br><span class="line">{</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">}</span><br><span class="line">}</span><br><span class="line">}</span><br><span class="line">}</span><br><span class="line"><span class="built_in">close</span>(sockfd);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"[TCP Server]: Close\n"</span>);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br><span class="line"></span><br></pre></td></tr></table></figure></li><li><p><strong><a href="https://gitee.com/geekdeveloper/gyatso-ichiro/blob/master/Linux-C%E5%92%8CC++%E5%90%8E%E7%AB%AF%E6%9C%8D%E5%8A%A1%E5%99%A8%E6%9E%B6%E6%9E%84%E5%BC%80%E5%8F%91/%E7%AC%AC2%E7%AB%A0-%E9%AB%98%E6%80%A7%E8%83%BD%E7%BD%91%E7%BB%9C%E8%AE%BE%E8%AE%A1/2.1.%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/tcp_server_epoll.c" title="TCP Server epoll() 模型">TCP Server epoll() 模型</a></strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">/*  TCP Server epoll  */</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">tcp_server_epoll</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line"><span class="keyword">char</span> recvmsg[TCP_SERVER_BUFF_SIZE] = { <span class="string">'\0'</span> };  <span class="comment">/*  服务器端接收数据缓冲区  */</span></span><br><span class="line"><span class="keyword">char</span> sendmsg[TCP_SERVER_BUFF_SIZE] = { <span class="string">'\0'</span> };  <span class="comment">/*  服务器端发送数据缓冲区  */</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*  创建套接字 sockfd  */</span></span><br><span class="line"><span class="keyword">int</span> sockfd = <span class="built_in">socket</span>(AF_INET, SOCK_STREAM, <span class="number">0</span>);</span><br><span class="line"><span class="keyword">if</span> (<span class="number">-1</span> == sockfd)</span><br><span class="line">{</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"[TCP Server]: Create a socket file descriptor error\n"</span>);</span><br><span class="line"><span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">}</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"[TCP Server]: Create a socket file descriptor succeed\n"</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">/*  填充数据结构体  struct sockaddr_in  */</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in</span> <span class="title">seraddr</span>;</span></span><br><span class="line"><span class="built_in">memset</span>(&amp;seraddr, <span class="number">0</span>, <span class="built_in"><span class="keyword">sizeof</span></span>(seraddr));</span><br><span class="line">seraddr.sin_family = AF_INET;                   <span class="comment">/*  地址族：IPv4  */</span></span><br><span class="line">seraddr.sin_port = <span class="built_in">htons</span>(TCP_SERVER_PORT);      <span class="comment">/*  端口号  */</span></span><br><span class="line">seraddr.sin_addr.s_addr = <span class="built_in">htonl</span>(TCP_SERVER_IP); <span class="comment">/*  IP地址  */</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*  绑定端口号和IP地址到套接字 sockfd  */</span></span><br><span class="line"><span class="keyword">if</span> (<span class="number">-1</span> == <span class="built_in">bind</span>(sockfd, (struct sockaddr*)&amp;seraddr, <span class="built_in"><span class="keyword">sizeof</span></span>(seraddr)))</span><br><span class="line">{</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"[TCP Server]: Bind a server IP addr  and port to sockfd error\n"</span>);</span><br><span class="line"><span class="keyword">return</span> <span class="number">-2</span>;</span><br><span class="line">}</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"[TCP Server]: Bind a server IP addr  and port to sockfd succeed\n"</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">/*  开始监听，设置最大链接数  */</span></span><br><span class="line"><span class="keyword">if</span> (<span class="number">-1</span> == <span class="built_in">listen</span>(sockfd, TCP_SERVER_BACKLOG))</span><br><span class="line">{</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"[TCP Server]: Listen for connections on a sockfd error\n"</span>);</span><br><span class="line"><span class="keyword">return</span> <span class="number">-3</span>;</span><br><span class="line">}</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"[TCP Server]: Listen for connections on a sockfd succeed\n"</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> epfd = <span class="built_in">epoll_create</span>(<span class="number">1</span>); <span class="comment">/*  参数只要大于0即可，实际无意义  */</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">epoll_event</span> <span class="title">events</span>[<span class="title">EPOLL_EVENTS_SIZE</span>] =</span> { <span class="number">0</span> };</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">epoll_event</span> <span class="title">ev</span>;</span></span><br><span class="line"><span class="built_in">memset</span>(&amp;ev, <span class="number">0</span>, <span class="built_in"><span class="keyword">sizeof</span></span>(ev));</span><br><span class="line">ev.events = EPOLLIN;</span><br><span class="line">ev.data.fd = sockfd;</span><br><span class="line"></span><br><span class="line"><span class="built_in">epoll_ctl</span>(epfd, EPOLL_CTL_ADD, sockfd, &amp;ev);</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in</span> <span class="title">cliaddr</span>;</span></span><br><span class="line"><span class="built_in">memset</span>(&amp;cliaddr, <span class="number">0</span>, <span class="built_in"><span class="keyword">sizeof</span></span>(cliaddr));</span><br><span class="line"><span class="keyword">socklen_t</span> cliaddrlen = <span class="built_in"><span class="keyword">sizeof</span></span>(cliaddr);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"[TCP Server]: Waiting for client's link request\n"</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> nready = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">int</span> evfd = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">int</span> clifd = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">ssize_t</span> reclen;</span><br><span class="line"><span class="built_in">memset</span>(&amp;reclen, <span class="number">0</span>, <span class="built_in"><span class="keyword">sizeof</span></span>(reclen));</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span> (<span class="number">1</span>)</span><br><span class="line">{</span><br><span class="line">nready = <span class="built_in">epoll_wait</span>(epfd, events, EPOLL_EVENTS_SIZE, <span class="number">5</span>);</span><br><span class="line"><span class="keyword">if</span> (<span class="number">-1</span> == nready)</span><br><span class="line">{</span><br><span class="line"><span class="keyword">continue</span>;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; nready; i++)</span><br><span class="line">{</span><br><span class="line">evfd = events[i].data.fd;</span><br><span class="line"><span class="keyword">if</span> (evfd == sockfd)</span><br><span class="line">{</span><br><span class="line"><span class="comment">/*  等待来自客户端的连接请求  */</span></span><br><span class="line"><span class="built_in">memset</span>(&amp;cliaddr, <span class="number">0</span>, <span class="built_in"><span class="keyword">sizeof</span></span>(cliaddr));</span><br><span class="line">cliaddrlen = <span class="built_in"><span class="keyword">sizeof</span></span>(cliaddr);</span><br><span class="line">clifd = <span class="built_in">accept</span>(sockfd, (struct sockaddr*)&amp;cliaddr, &amp;cliaddrlen);</span><br><span class="line"><span class="keyword">if</span> (<span class="number">-1</span> == clifd)</span><br><span class="line">{</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"[TCP Server]: Accept a connection on a clifd error\n"</span>);</span><br><span class="line"><span class="keyword">return</span> <span class="number">-4</span>;</span><br><span class="line">}</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"[TCP Server]: Accept a connection on a clifd succeed\n"</span>);</span><br><span class="line"></span><br><span class="line">ev.events = EPOLLIN;</span><br><span class="line">ev.data.fd = clifd;</span><br><span class="line"><span class="built_in">epoll_ctl</span>(epfd, EPOLL_CTL_ADD, clifd, &amp;ev);</span><br><span class="line">}</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">{</span><br><span class="line"><span class="keyword">if</span> (events[i].events &amp; EPOLLIN)</span><br><span class="line">{</span><br><span class="line"><span class="built_in">bzero</span>(recvmsg, TCP_SERVER_BUFF_SIZE);</span><br><span class="line">reclen = <span class="built_in">recv</span>(evfd, recvmsg, TCP_SERVER_BUFF_SIZE, <span class="number">0</span>);</span><br><span class="line"><span class="keyword">if</span> (reclen &gt; <span class="number">0</span>)</span><br><span class="line">{</span><br><span class="line">recvmsg[reclen] = <span class="string">'\0'</span>;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"[TCP Server]: From %s client message: (%s)\n"</span>, <span class="built_in">inet_ntoa</span>(cliaddr.sin_addr), recvmsg);</span><br><span class="line"><span class="built_in">bzero</span>(sendmsg, TCP_SERVER_BUFF_SIZE);</span><br><span class="line"><span class="built_in">strcpy</span>(sendmsg, recvmsg);</span><br><span class="line"><span class="built_in">send</span>(evfd, sendmsg, <span class="built_in">strlen</span>(sendmsg) + <span class="number">1</span>, <span class="number">0</span>);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"[TCP Server]: To client send message: (%s)\n"</span>, <span class="built_in">inet_ntoa</span>(cliaddr.sin_addr));</span><br><span class="line">}</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (<span class="number">0</span> == reclen)</span><br><span class="line">{</span><br><span class="line">ev.events = EPOLLIN;</span><br><span class="line">ev.data.fd = evfd;</span><br><span class="line"><span class="built_in">epoll_ctl</span>(epfd, EPOLL_CTL_DEL, events[i].data.fd, &amp;ev);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"Client close\n"</span>);</span><br><span class="line"><span class="built_in">close</span>(evfd);</span><br><span class="line">}</span><br><span class="line">}</span><br><span class="line">}</span><br><span class="line">}</span><br><span class="line">}</span><br><span class="line"><span class="built_in">close</span>(sockfd);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"TCP Server close\n"</span>);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br><span class="line"></span><br></pre></td></tr></table></figure></li></ul>]]></content>
    
    
    <summary type="html">网络 I/O 多路复用技术(select、poll、epoll)</summary>
    
    
    
    <category term="网络技术" scheme="http://example.com/categories/%E7%BD%91%E7%BB%9C%E6%8A%80%E6%9C%AF/"/>
    
    
    <category term="技术博客" scheme="http://example.com/tags/%E6%8A%80%E6%9C%AF%E5%8D%9A%E5%AE%A2/"/>
    
  </entry>
  
  <entry>
    <title>Markdown 基本语法及 Markdown 文档模板</title>
    <link href="http://example.com/2021/12/14/hello-world/"/>
    <id>http://example.com/2021/12/14/hello-world/</id>
    <published>2021-12-14T15:35:21.184Z</published>
    <updated>2021-12-14T16:34:43.888Z</updated>
    
    <content type="html"><![CDATA[<p><strong>Markdown 是一种轻量级标记语言，排版语法简洁，让人们更多地关注内容本身而非排版。它使用易读易写的纯文本格式编写文档，可与 HTML 混编，可导出 HTML、PDF 以及本身的 .md 格式的文件。因简洁、高效、易读、易写，Markdown 被大量使用，如 Github、Wikipedia、简书等。</strong></p><h2 id="第1章-标题"><a href="#第1章-标题" class="headerlink" title="第1章 标题"></a>第1章 标题</h2><p><strong>不同数量的<code>#</code>可以完成不同的标题，如下：</strong></p><blockquote><ul><li><strong>题目：# xxxx-xxxx</strong></li><li><strong>章节：## 第1章 xxxx</strong></li><li><strong>三级：### 1.1 xxxx</strong></li><li><strong>四级：#### 1.1.1 xxxx</strong></li></ul></blockquote><h2 id="第2章-字体"><a href="#第2章-字体" class="headerlink" title="第2章 字体"></a>第2章 字体</h2><ul><li><p><strong>2.1 粗体</strong></p><ul><li><strong>这个是粗体(不能有空格)</strong></li></ul></li><li><p><strong>2.2 斜体</strong></p><ul><li><em>这个是斜体</em></li></ul></li><li><p><strong>2.3 粗体加斜体</strong></p><ul><li><em><strong>这个是粗体加斜体</strong></em></li></ul></li><li><p><strong>2.4 删除线</strong></p></li></ul><p>~这里想用删除线~~</p><h2 id="第3章-列表"><a href="#第3章-列表" class="headerlink" title="第3章 列表"></a>第3章 列表</h2><h3 id="3-1-无序列表"><a href="#3-1-无序列表" class="headerlink" title="3.1 无序列表"></a>3.1 无序列表</h3><h4 id="3-1-1-无序列表的使用，在符号-后加空格使用。如下："><a href="#3-1-1-无序列表的使用，在符号-后加空格使用。如下：" class="headerlink" title="3.1.1 无序列表的使用，在符号 - 后加空格使用。如下："></a>3.1.1 无序列表的使用，在符号 <code>-</code> 后加空格使用。如下：</h4><ul><li>无序列表 1</li><li>无序列表 2</li><li>无序列表 3</li></ul><h4 id="3-1-2-如果要控制列表的层级，则需要在符号-前使用空格。如下："><a href="#3-1-2-如果要控制列表的层级，则需要在符号-前使用空格。如下：" class="headerlink" title="3.1.2 如果要控制列表的层级，则需要在符号 - 前使用空格。如下："></a>3.1.2 如果要控制列表的层级，则需要在符号 <code>-</code> 前使用空格。如下：</h4><ul><li>无序列表 1</li><li>无序列表 2<ul><li>无序列表 2.1</li><li>无序列表 2.2</li></ul></li></ul><h3 id="3-2-有序列表"><a href="#3-2-有序列表" class="headerlink" title="3.2 有序列表"></a>3.2 有序列表</h3><p><strong>有序列表的使用，在数字及符号 <code>.</code> 后加空格后输入内容，如下：</strong></p><ol><li>有序列表 1</li><li>有序列表 2</li><li>有序列表 3</li></ol><h2 id="第4章-引用"><a href="#第4章-引用" class="headerlink" title="第4章 引用"></a>第4章 引用</h2><p><strong>引用的格式是在符号 <code>&gt;</code> 后面书写文字。如下：</strong></p><blockquote><p>读一本好书，就是在和高尚的人谈话。 ——歌德</p></blockquote><blockquote><p>科学是一种强大的智慧力量，它致力于破除禁锢着我的神秘的桎梏。——高尔基</p></blockquote><blockquote><p>一面科技，一面艺术。——青年报 - 昨日</p></blockquote><h2 id="第5章-链接"><a href="#第5章-链接" class="headerlink" title="第5章 链接"></a>第5章 链接</h2><p>Linux 内核网站：<a href="https://mirrors.edge.kernel.org/pub/linux/kernel/">https://mirrors.edge.kernel.org/pub/linux/kernel/</a></p><p>Linux 内核网站：<code>https://mirrors.edge.kernel.org/pub/linux/kernel/</code></p><p><a href="https://mirrors.edge.kernel.org/pub/linux/kernel/">Linux 内核源码下载链接</a></p><h2 id="第6章-图片"><a href="#第6章-图片" class="headerlink" title="第6章 图片"></a>第6章 图片</h2><p><strong>插入图片，格式如下：</strong></p><p><img src="https://www.nginx.cn/wp-content/uploads/2020/03/qrcode_for_gh_82cf87d482f0_258.jpg" alt="这里写图片描述"></p><p>支持 jpg、png、gif、svg 等图片格式，<strong>其中 svg 文件仅可在微信公众平台中使用</strong></p><h2 id="第7章-分割线"><a href="#第7章-分割线" class="headerlink" title="第7章 分割线"></a>第7章 分割线</h2><p><strong>可以在一行中用三个以上的减号来建立一个分隔线，同时需要在分隔线的上面空一行。如下：</strong></p><hr><h2 id="第8章-表格"><a href="#第8章-表格" class="headerlink" title="第8章 表格"></a>第8章 表格</h2><p><strong>可以使用冒号来定义表格的对齐方式，如下：</strong></p><table><thead><tr><th align="left">姓名</th><th align="center">年龄</th><th align="right">工作</th></tr></thead><tbody><tr><td align="left">小可爱</td><td align="center">18</td><td align="right">吃可爱多</td></tr><tr><td align="left">小小勇敢</td><td align="center">20</td><td align="right">爬棵勇敢树</td></tr><tr><td align="left">小小小机智</td><td align="center">22</td><td align="right">看一本机智书</td></tr></tbody></table><h2 id="第9章-特殊语法"><a href="#第9章-特殊语法" class="headerlink" title="第9章 特殊语法"></a>第9章 特殊语法</h2><h3 id="9-1-脚注"><a href="#9-1-脚注" class="headerlink" title="9.1 脚注"></a>9.1 脚注</h3><p>有人认为在<a href="https://en.wikipedia.org/wiki/Front-end_web_development" title="Front-end web development">大前端时代</a>的背景下，移动端开发（Android、IOS）将逐步退出历史舞台。</p><p><a href="%E6%98%AF%E6%8C%87%E6%8E%8C%E6%8F%A1%E5%A4%9A%E7%A7%8D%E6%8A%80%E8%83%BD%EF%BC%8C%E5%B9%B6%E8%83%BD%E5%88%A9%E7%94%A8%E5%A4%9A%E7%A7%8D%E6%8A%80%E8%83%BD%E7%8B%AC%E7%AB%8B%E5%AE%8C%E6%88%90%E4%BA%A7%E5%93%81%E7%9A%84%E4%BA%BA%E3%80%82" title="什么是全栈工程师">全栈工程师</a>在业务开发流程中起到了至关重要的作用。</p><h3 id="9-2-代码块"><a href="#9-2-代码块" class="headerlink" title="9.2 代码块"></a>9.2 代码块</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * list_rotate_left - rotate the list to the left</span></span><br><span class="line"><span class="comment"> * @head: the head of the list</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">list_rotate_left</span><span class="params">(struct list_head *head)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">list_head</span> *<span class="title">first</span>;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (!<span class="built_in">list_empty</span>(head)) &#123;</span><br><span class="line">first = head-&gt;next;</span><br><span class="line"><span class="built_in">list_move_tail</span>(first, head);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;&lt;strong&gt;Markdown 是一种轻量级标记语言，排版语法简洁，让人们更多地关注内容本身而非排版。它使用易读易写的纯文本格式编写文档，可与 HTML 混编，可导出 HTML、PDF 以及本身的 .md 格式的文件。因简洁、高效、易读、易写，Markdown 被大量使用</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>博客简介</title>
    <link href="http://example.com/2021/12/14/%E7%AE%80%E4%BB%8B/"/>
    <id>http://example.com/2021/12/14/%E7%AE%80%E4%BB%8B/</id>
    <published>2021-12-13T16:54:08.000Z</published>
    <updated>2021-12-14T17:00:36.815Z</updated>
    
    <content type="html"><![CDATA[<p><strong>于辛丑牛年农历冬月拾壹正式运营个人技术博客</strong></p><blockquote><p><strong>2021-12-24</strong></p></blockquote><blockquote><p><strong>Gyatso Ichiro</strong></p></blockquote>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;&lt;strong&gt;于辛丑牛年农历冬月拾壹正式运营个人技术博客&lt;/strong&gt;&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;strong&gt;2021-12-24&lt;/strong&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;strong&gt;Gyatso I</summary>
      
    
    
    
    
  </entry>
  
</feed>
